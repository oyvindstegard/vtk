<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sqlMap PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN" 
                 "http://ibatis.apache.org/dtd/sql-map-2.dtd"> 

<sqlMap>

  <resultMap id="Resource" class="java.util.HashMap">
    <result property="uri" column="uri" />
    <result property="id" column="resource_id" javaType="int"/>
    <result property="resourceType" column="resource_type"/>
    <result property="creationTime" column="creation_time" javaType="date"/>
    <result property="createdBy" column="created_by" />
    <result property="contentLastModified" column="content_last_modified" javaType="date"/>
    <result property="propertiesLastModified" column="properties_last_modified" javaType="date"/>
    <result property="lastModified" column="last_modified" javaType="date"/>
    <result property="contentModifiedBy" column="content_modified_by" />
    <result property="propertiesModifiedBy" column="properties_modified_by" />
    <result property="modifiedBy" column="modified_by" />
    <result property="owner" column="resource_owner" />
    <result property="contentLanguage" column="content_language" />
    <result property="contentType" column="content_type" />
    <result property="contentLength" column="content_length" javaType="long" />
    <result property="characterEncoding" column="character_encoding" />
    <result property="guessedCharacterEncoding" column="guessed_character_encoding" />
    <result property="userSpecifiedCharacterEncoding" column="user_character_encoding" />
    <result property="isCollection" column="is_collection" />
    <result property="aclInheritedFrom" column="acl_inherited_from" javaType="int" />
  </resultMap>


  <resultMap id="UriResourceId" class="java.util.HashMap">
    <result property="uri" column="uri" />
    <result property="resourceId" column="resource_id" javaType="int" />
  </resultMap>


  <resultMap id="ResourceIdInheritedFromMap" class="java.util.HashMap">
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="inheritedFrom" column="inherited_from" javaType="int" />
  </resultMap>


  <resultMap id="Property" class="java.util.HashMap">
    <result property="id" column="extra_prop_entry_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="name" column="name" />
    <result property="namespaceUri" column="name_space" />
    <result property="value" column="value" />
    <result property="binary" column="is_binary"
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
    <result property="inherited" column="is_inherited"
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>

  <resultMap id="UriAndProperty" class="java.util.HashMap">
    <result property="uri" column="uri" />
    <result property="id" column="extra_prop_entry_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="name" column="name" />
    <result property="namespaceUri" column="name_space" />
    <result property="value" column="value" />
    <result property="binary" column="is_binary"
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
    <result property="inherited" column="is_inherited"
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>




  <resultMap id="AclEntry" class="java.util.HashMap">
    <result property="id" column="acl_entry_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="action" column="action_type" />
    <result property="principal" column="user_or_group_name" />
    <result property="isUser" column="is_user" />
  </resultMap>

  <resultMap id="Principal" class="java.util.HashMap">
    <result property="name" column="user_or_group_name" />
    <result property="isUser" column="is_user" 
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback" />
  </resultMap>

  <resultMap id="ActionType" class="java.util.HashMap">
    <result property="id" column="action_type_id" javaType="int" />
    <result property="name" column="name" />
  </resultMap>
  
  <resultMap id="UserOrGroupName" class="java.lang.String">
    <result property="userOrGroupName"/>
  </resultMap>
  
  <resultMap id="Lock" class="java.util.HashMap">
    <result property="id" column="lock_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="uri" column="uri" />
    <result property="token" column="token" />
    <result property="owner" column="lock_owner" />
    <result property="ownerInfo" column="lock_owner_info" />
    <result property="depth" column="depth" />
    <result property="timeout" column="timeout" javaType="date" />
  </resultMap>

  <resultMap id="ResourceAndExtraProperties" class="java.util.HashMap"
    extends="Resource">
    
    <!-- Some columns from 'extra_prop_entry' -->
    <result property="name" column="name" />
    <result property="namespace" column="name_space" />
    <result property="value" column="value" />
    <result property="binary" column="is_binary"
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
    <result property="inherited" column="is_inherited"
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>
  
  <!-- ChangeLog entry result mapping -->
  <resultMap id="ChangeLogEntry" class="org.vortikal.repository.ChangeLogEntry">
    <result property="changeLogEntryId" column="changelog_entry_id" javaType="int"/>
    <result property="loggerId" column="logger_id" javaType="int"/>
    <result property="loggerType" column="logger_type" javaType="int"/>
    <result property="uri" column="uri" typeHandler="org.vortikal.repository.store.db.ibatis.PathTypeHandlerCallback"/>
    <result property="resourceId" column="resource_id" javaType="int" nullValue="-1"/>
    <result property="operation" column="operation" 
      typeHandler="org.vortikal.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback"/>
    <result property="collection" column="is_collection"
      typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
    <result property="timestamp" column="timestamp" javaType="date"/>
  </resultMap>


  <select id="loadResourceByUri" resultMap="Resource">
    select * from vortex_resource where uri = #value#
  </select>

  <select id="loadResourceIdByUri" resultMap="UriResourceId">
    select uri, resource_id from vortex_resource where uri = #value#
  </select>

  <update id="updateResource" parameterClass="java.util.Map">
    update vortex_resource set
      content_last_modified = #contentLastModified#,
      properties_last_modified = #propertiesLastModified#,
      content_modified_by = #contentModifiedBy#,
      properties_modified_by = #propertiesModifiedBy#,
      resource_owner = #owner#,
      content_language = #contentLanguage#,
      content_type = #contentType#,
      character_encoding = #characterEncoding#,
      guessed_character_encoding = #guessedCharacterEncoding#,
      user_character_encoding = #userSpecifiedCharacterEncoding#,
      creation_time = #creationTime#,
      resource_type = #resourceType#,
      content_length = #contentLength#,
      created_by = #createdBy#,
      modified_by = #modifiedBy#,
      last_modified = #lastModified#
    where uri = #uri#
  </update>


  <insert id="insertResource" parameterClass="java.util.Map">
    insert into vortex_resource 
      (resource_id,
       uri,
       resource_type,
       content_length,
       depth,
       creation_time,
       content_last_modified,
       properties_last_modified,
       content_modified_by,
       properties_modified_by,
       resource_owner,
       content_language,
       content_type,
       character_encoding,
       guessed_character_encoding,
       user_character_encoding,
       is_collection,
       acl_inherited_from,
       created_by,
       modified_by,
       last_modified)

    values 
      (<include refid="nextVortexResourceId" />,
       #uri#,
       #resourceType#,
       #contentLength#,
       #depth#,
       #creationTime#,
       #contentLastModified#,
       #propertiesLastModified#,
       #contentModifiedBy#,
       #propertiesModifiedBy#,
       #owner#,
       #contentLanguage#, 
       #contentType#,
       #characterEncoding#,
       #guessedCharacterEncoding#,
       #userSpecifiedCharacterEncoding#,
       #collection#,
       #aclInheritedFrom#,
       #createdBy#,
       #modifiedBy#,
       #lastModified#)
  </insert>


  <!-- Allows overriding most of the properties by supplying values in the parameter map -->
  <insert id="copyResource" parameterClass="java.util.Map">
    insert into vortex_resource 
      (resource_id,
       uri,
       prev_resource_id,
       resource_type,
       content_length,
       depth,
       creation_time,
       content_last_modified,
       properties_last_modified,
       content_modified_by,
       properties_modified_by,
       resource_owner,
       content_language,
       content_type,
       character_encoding,
       guessed_character_encoding,
       user_character_encoding,
       is_collection,
       acl_inherited_from,
       created_by,
       modified_by,
       last_modified)

    select
      <include refid="nextVortexResourceId" />,
      <include refid="destinationUriCopy" />,
      resource_id,
      resource_type,
      content_length,
      depth + #depthDiff#,
      <isPropertyAvailable property="creationTime">#creationTime#,</isPropertyAvailable>
      <isNotPropertyAvailable property="creationTime">creation_time,</isNotPropertyAvailable>
      <isPropertyAvailable property="contentLastModified">#contentLastModified#,</isPropertyAvailable>
      <isNotPropertyAvailable property="contentLastModified">content_last_modified,</isNotPropertyAvailable>
      <isPropertyAvailable property="propertiesLastModified">#propertiesLastModified#,</isPropertyAvailable>
      <isNotPropertyAvailable property="propertiesLastModified">properties_last_modified,</isNotPropertyAvailable>
      <isPropertyAvailable property="contentModifiedBy">#contentModifiedBy#,</isPropertyAvailable>
      <isNotPropertyAvailable property="contentModifiedBy">content_modified_by,</isNotPropertyAvailable>
      <isPropertyAvailable property="propertiesModifiedBy">#propertiesModifiedBy#,</isPropertyAvailable>
      <isNotPropertyAvailable property="propertiesModifiedBy">properties_modified_by,</isNotPropertyAvailable>
      <isPropertyAvailable property="owner">#owner#,</isPropertyAvailable>
      <isNotPropertyAvailable property="owner">resource_owner,</isNotPropertyAvailable>
      <isPropertyAvailable property="contentLanguage">#contentLanguage#,</isPropertyAvailable>
      <isNotPropertyAvailable property="contentLanguage">content_language,</isNotPropertyAvailable>
      <isPropertyAvailable property="contentType">#contentType#,</isPropertyAvailable>
      <isNotPropertyAvailable property="contentType">content_type,</isNotPropertyAvailable>
      <isPropertyAvailable property="characterEncoding">#characterEncoding#,</isPropertyAvailable>
      <isNotPropertyAvailable property="characterEncoding">character_encoding,</isNotPropertyAvailable>
      <isPropertyAvailable property="guessedCharacterEncoding">#guessedCharacterEncoding#,</isPropertyAvailable>
      <isNotPropertyAvailable property="guessedCharacterEncoding">guessed_character_encoding,</isNotPropertyAvailable>
      <isPropertyAvailable property="userSpecifiedCharacterEncoding">#userSpecifiedCharacterEncoding#,</isPropertyAvailable>
      <isNotPropertyAvailable property="userSpecifiedCharacterEncoding">user_character_encoding,</isNotPropertyAvailable>
      is_collection,
      acl_inherited_from,
      <isPropertyAvailable property="createdBy">#createdBy#,</isPropertyAvailable>
      <isNotPropertyAvailable property="createdBy">created_by,</isNotPropertyAvailable>
      <isPropertyAvailable property="modifiedBy">#modifiedBy#,</isPropertyAvailable>
      <isNotPropertyAvailable property="modifiedBy">modified_by,</isNotPropertyAvailable>
      <isPropertyAvailable property="lastModified">#lastModified#</isPropertyAvailable>
      <isNotPropertyAvailable property="lastModified">last_modified</isNotPropertyAvailable>
    from vortex_resource
    where uri = #srcUri# or uri like #uriWildcard# escape '@'
  </insert>

  
  <update id="moveResource" parameterClass="java.util.Map">
    update vortex_resource set
        uri = #destUri#,
        depth = depth + #depthDiff#
    where uri = #srcUri#
  </update>

  <update id="moveDescendants" parameterClass="java.util.Map">
    update vortex_resource set
        uri = <include refid="destinationDescendantUriMove" />,
        depth = depth + #depthDiff#
    where uri like #uriWildcard# escape '@'
  </update>


  <!-- ## DELETING ## -->
  
  <!-- ## Permanently delete ## -->
  <delete id="deleteResourceByUri" parameterClass="java.util.Map">
    delete from vortex_resource where uri = #uri# or uri like #uriWildcard# escape '@'
  </delete>
  
  <!-- ## Mark as deleted ("put in trash can") ## -->
  <update id="markDeleted" parameterClass="java.util.Map">
    update vortex_resource set
      uri = <include refid="trashCanUri" />,
      depth = depth + #depthDiff#
      where uri = #uri# or uri like #uriWildcard# escape '@'
  </update>

  <insert id="insertTrashCanEntry" parameterClass="java.util.Map">
    insert into deleted_resource (id, resource_trash_uri, parent_id, deleted_by, deleted_time, was_inherited_acl)
      values (<include refid="nextDeletedResourceId" />,
              #trashCanURI#, #parentID#, #principal#, #deletedTime#, #wasInheritedAcl#)
  </insert>

  <!-- ## Display recoverable resources (trash can contents) ## -->
  <resultMap id="recoverableResource" class="org.vortikal.repository.RecoverableResource">
    <result property="id" column="id" />
    <result property="trashUri" column="resource_trash_uri" />
    <result property="parentId" column="parent_id" />
    <result property="deletedBy" column="deleted_by" />
    <result property="deletedTime" column="deleted_time" />
    <result property="wasInheritedAcl" column="was_inherited_acl" 
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback" />
    <result property="resourceType" column="resource_type" />
    <result property="contentType" column="content_type" />
    <result property="isCollection" column="is_collection"
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback" />
  </resultMap>

  <select id="getRecoverableResources" parameterClass="int" resultMap="recoverableResource">
    select d.*, r.resource_type, r.content_type, r.is_collection
      from deleted_resource d, vortex_resource r
      where d.parent_id = #value# and d.resource_trash_uri = r.uri
  </select>

  <select id="getRecoverableResourceById" parameterClass="int" resultMap="recoverableResource">
    select d.*, r.resource_type, r.content_type, r.is_collection
      from deleted_resource d, vortex_resource r
      where d.id = #value# and d.resource_trash_uri = r.uri
  </select>

  <!--  ## Recover deleted resource ## -->
  <update id="recoverResource" parameterClass="java.util.Map">
    update vortex_resource set
      uri = <include refid="recoverUri" />,
      depth = depth + #depthDiff#
      where uri like #trashIDWildcard# escape '@'
  </update>

  <delete id="deleteFromTrashCan" parameterClass="int">
    delete from deleted_resource where id = #value#
  </delete>

  <!-- ## Permanently delete a resource that has already been marked for deletion (moved to trash can) ##-->
  <delete id="deletePermanentlyMarkDeleted" parameterClass="java.util.Map">
    delete from vortex_resource where uri = #trashCanURI# or uri like #trashCanURIWildCard# escape '@'
  </delete>

  <!-- ## Get resources that have been deleted longer than a given limit ## -->
  <select id="getOverdue" parameterClass="java.util.Date" resultMap="recoverableResource">
    select d.*, r.resource_type, r.content_type, r.is_collection
      from deleted_resource d, vortex_resource r
      where d.deleted_time &lt; #value# and d.resource_trash_uri = r.uri
  </select>

  <!-- ## Get resources that have been deleted and are orphans (parent has been permanently deleted) ## -->
  <select id="getOrphans" resultMap="recoverableResource">
    select d.*, r.resource_type, r.content_type, r.is_collection
      from deleted_resource d, vortex_resource r
      where d.resource_trash_uri = r.uri
        and d.parent_id not in (select resource_id from vortex_resource)
  </select>

  <select id="loadChildren" parameterClass="java.util.Map"
          resultMap="Resource">
    select * from vortex_resource where uri like #uriWildcard# escape '@' and depth = #depth#
  </select>

  <select id="loadChildUrisForChildren" parameterClass="java.util.Map"
                                        resultClass="org.vortikal.repository.Path">
    select uri from vortex_resource where uri like #uriWildcard# escape '@' and depth = #depth# 
  </select>

  <update id="updateAclInheritedFromByResourceId" parameterClass="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #inheritedFrom#
      where resource_id = #resourceId#
  </update>


  <update id="updateAclInheritedFromByUri" parameterClass="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #inheritedFrom#
      where uri = #uri# or uri like #uriWildcard# escape '@'
  </update>


  <update id="updateAclInheritedFromByPreviousInheritedFromAndUri" parameterClass="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #inheritedFrom#
      where (uri = #uri# or uri like #uriWildcard# escape '@')
             and acl_inherited_from = #previouslyInheritedFrom#
  </update>


  <update id="updateAclInheritedFromByResourceIdOrPreviousInheritedFrom" parameterClass="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #inheritedFrom#
      where acl_inherited_from = #previouslyInheritedFrom#
        or resource_id = #resourceId#
  </update>


  <select id="loadPreviousInheritedFromMap" parameterClass="java.util.Map"
          resultMap="ResourceIdInheritedFromMap">
    select
      r1.resource_id,
      r2.resource_id as inherited_from 
    from vortex_resource r1, vortex_resource r2 
    where (r1.uri = #uri# or r1.uri like #uriWildcard# escape '@')
           and r2.prev_resource_id = r1.acl_inherited_from
  </select>


  <update id="clearPrevResourceIdByUri" parameterClass="java.util.Map">
    update vortex_resource
      set prev_resource_id = null
      where uri = #uri# or uri like #uriWildcard# escape '@'
  </update>


  <select id="loadActionTypes" resultMap="ActionType">
    select * from action_type
  </select>


  <select id="loadPropertiesForResource" parameterClass="int" resultMap="Property">
    select
      p.*,
      case when binary_content is null then 'N' else 'Y' end as is_binary
    from extra_prop_entry p
    where resource_id = #value#
    and is_inherited = 'N'
    order by p.extra_prop_entry_id
  </select>


  <select id="loadPropertiesForChildren" parameterClass="java.util.Map"
          resultMap="Property">
    select
      p.*,
      case when binary_content is null then 'N' else 'Y' end as is_binary
    from extra_prop_entry p
    where p.resource_id in
      (select resource_id from vortex_resource
        where uri like #uriWildcard# escape '@' and depth = #depth#)
    and p.is_inherited = 'N'
    order by p.resource_id, p.extra_prop_entry_id
  </select>
  
  <select id="loadInheritedProperties" parameterClass="java.util.Map"
          resultMap="UriAndProperty">
    select
      r.uri,
      p.*,
      case when p.binary_content is null then 'N' else 'Y' end as is_binary
    from vortex_resource r inner join extra_prop_entry p on p.resource_id = r.resource_id
    where p.is_inherited = 'Y'
          and r.uri in 
          <iterate prepend="" property="uris" open="(" close=")" conjunction=","> 
               #uris[]# 
          </iterate>
    order by p.resource_id, p.extra_prop_entry_id
  </select>

  <resultMap id="ByteArray" class="java.util.HashMap">
    <result property="byteArray" column="binary_content"
            typeHandler="org.springframework.orm.ibatis.support.BlobByteArrayTypeHandler" />
  </resultMap>

  <select id="selectBinaryPropertyEntry" parameterClass="java.lang.Integer"
                                         resultMap="ByteArray">
    select binary_content from extra_prop_entry where extra_prop_entry_id = #value#
  </select>
  
  <select id="selectBinaryMimeTypeEntry" parameterClass="java.lang.Integer" resultClass="java.lang.String">
    select binary_mimetype from extra_prop_entry where extra_prop_entry_id = #value#
  </select>
  
  <insert id="insertPropertyEntry" parameterClass="java.util.Map">
    insert into extra_prop_entry
      (extra_prop_entry_id, resource_id, name_space, name, value
        <isNotEmpty property="binaryContent">
          , binary_content, binary_mimetype
        </isNotEmpty>
        , is_inherited)
    values (<include refid="nextExtraPropEntryId" />, #resourceId#, 
      #namespaceUri#, #name#, #value#
        <isNotEmpty property="binaryContent">
          , #binaryContent,handler=org.springframework.orm.ibatis.support.BlobByteArrayTypeHandler#,
          #binaryMimeType#
        </isNotEmpty>
        , #inherited,handler=org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback#)
  </insert>
  
  <insert id="copyProperties" parameterClass="java.util.Map">
    insert into extra_prop_entry
      (extra_prop_entry_id,
       resource_id,
       name_space,
       name,
       value,
       binary_content,
       binary_mimetype,
       is_inherited)
    select
      <include refid="nextExtraPropEntryId" />, t.*
      from
        (select
          r.resource_id,
          p.name_space,
          p.name,
          p.value,
          p.binary_content,
          p.binary_mimetype,
          p.is_inherited
        from vortex_resource r inner join extra_prop_entry p 
             on r.prev_resource_id = p.resource_id
        where (r.uri = #destUri# or r.uri like #destUriWildcard# escape '@')
          and r.prev_resource_id is not null
          order by p.extra_prop_entry_id) t
  </insert>
  
  <delete id="deleteUncopyableProperties" parameterClass="java.util.HashMap">
    delete from extra_prop_entry
      where name = #name# and resource_id in
        (select resource_id from vortex_resource where uri = #destUri# or uri like #uriWildcard#)
  </delete>
  
  <delete id="deletePropertiesByResourceId" parameterClass="int">
    delete from extra_prop_entry where resource_id = #resourceId#
  </delete>


  <delete id="deletePropertiesByUri" parameterClass="java.util.Map">
    delete from extra_prop_entry where resource_id in
      (select resource_id from vortex_resource
       where uri = #uri# or uri like #uriWildcard# escape '@')
  </delete>


  <select id="loadAclEntriesByResourceIds" resultMap="AclEntry">
    select
      r.resource_id as resource_id,
      a.*,
      t.name as action_type
    from acl_entry a
      inner join action_type t on a.action_type_id = t.action_type_id
      inner join vortex_resource r on r.resource_id = a.resource_id
    where r.resource_id in 

    <iterate prepend="" property="resourceIds" open="(" close=")" conjunction=","> 
             #resourceIds[]# 
    </iterate> 
  </select>

  
  <insert id="insertAclEntry" parameterClass="java.util.Map">
    insert into acl_entry
      (acl_entry_id, action_type_id, resource_id, user_or_group_name,
       is_user, granted_by_user_name, granted_date)
    values (<include refid="nextAclEntryId" />, #actionId#, #resourceId#, #principal#,
            #isUser#, #grantedBy#, #grantedDate#)
  </insert>

  
  <insert id="copyAclEntries" parameterClass="java.util.Map">
    insert into acl_entry
      (acl_entry_id,
       resource_id,
       action_type_id,
       user_or_group_name,
       is_user,
       granted_by_user_name,
       granted_date)
     select
       <include refid="nextAclEntryId" />,
       r.resource_id,
       a.action_type_id,
       a.user_or_group_name,
       a.is_user,
       a.granted_by_user_name,
       a.granted_date
     from vortex_resource r inner join acl_entry a
       on r.prev_resource_id = a.resource_id 
     where (r.uri = #destUri#  or r.uri like #destUriWildcard# escape '@')
            and r.prev_resource_id is not null    
  </insert>
  

  <select id="discoverAcls" parameterClass="java.util.Map" resultClass="org.vortikal.repository.Path">
    select distinct
      r.uri as uri
    from acl_entry a inner join vortex_resource r on a.resource_id = r.resource_id
    where r.acl_inherited_from is null and r.resource_id in
      (select resource_id from vortex_resource where uri like #uriWildcard# escape '@' or uri =  #uri#)
  </select>


  <delete id="deleteAclEntriesByUri" parameterClass="java.util.Map">
    delete from acl_entry where resource_id in
      (select resource_id from vortex_resource
       where uri = #uri# or uri like #uriWildcard# escape '@')
  </delete>


  <delete id="deleteAclEntriesByResourceId" parameterClass="int">
    delete from acl_entry where resource_id = #id#
  </delete>


  <select id="isInheritedAcl" parameterClass="int" resultMap="ResourceIdInheritedFromMap">
    select
      acl_inherited_from as inherited_from, resource_id
    from vortex_resource
    where resource_id = #value#
  </select>


  <select id="findNearestAclResourceId" resultMap="UriResourceId">
    select
      r.resource_id, r.uri 
    from acl_entry a
      inner join vortex_resource r on r.resource_id = a.resource_id 
    where r.uri in 
    <iterate prepend="" property="path" open="(" close=")" conjunction=","> 
             #path[]# 
    </iterate> 
  </select>


  <select id="loadLocksForChildren" parameterClass="java.util.Map"
          resultMap="Lock">
    select
      r.uri as uri, l.*
    from vortex_resource r
      inner join vortex_lock l on r.resource_id = l.resource_id
      where l.timeout >= #timestamp# and r.resource_id in (select resource_id 
        from vortex_resource where uri like #uriWildcard# escape '@' and depth = #depth#)
  </select>


  <select id="loadLocksByUris" parameterClass="java.util.Map"
          resultMap="Lock">
    select
      r.uri as uri, l.*
    from vortex_resource r
      inner join vortex_lock l on r.resource_id = l.resource_id
      where l.timeout >= #timestamp# and r.uri in 
    <iterate prepend="" property="uris" open="(" close=")" conjunction=","> 
             #uris[]# 
    </iterate> 
  </select>


  <select id="loadLockByLockToken" parameterClass="string" resultMap="Lock">
    select
      r.uri as uri, l.*
    from vortex_resource r
      inner join vortex_lock l on r.resource_id = l.resource_id
      where l.token = #value#
  </select>


  <insert id="insertLock" parameterClass="java.util.Map">
    insert into vortex_lock
      (lock_id, token, resource_id, lock_owner,
       lock_owner_info, depth, timeout)
     values (<include refid="nextLockId" />,
            #lockToken#, #resourceId#, #owner#,
            #ownerInfo#, #depth#, #timeout#)
  </insert>


  <update id="updateLock" parameterClass="java.util.Map">
    update vortex_lock
      set lock_owner = #owner#,
          lock_owner_info = #ownerInfo#,
          depth = #depth#,
          timeout = #timeout#
      where token = #lockToken#
  </update>


  <delete id="deleteLockByResourceId" parameterClass="int">
    delete from vortex_lock where resource_id = #value#
  </delete>


  <delete id="deleteLocksByUri" parameterClass="java.util.Map">
    delete from vortex_lock where resource_id in
      (select resource_id from vortex_resource
       where uri = #uri# or uri like #uriWildcard# escape '@')
  </delete>


  <delete id="deleteExpiredLocks">
    delete from vortex_lock where timeout &lt; #value#
  </delete>

  <select id="discoverLocks" parameterClass="java.util.Map"
                             resultClass="java.lang.String">
    select
      r.uri from vortex_resource r
        inner join vortex_lock l on r.resource_id = l.resource_id
    where l.timeout &gt; #timestamp# and r.uri like #uriWildcard# escape '@'
  </select>
  
  <select id="discoverGroups" resultMap="UserOrGroupName">
    select user_or_group_name from acl_entry where is_user = 'N'
    union
    select user_or_group_name from revision_acl_entry where is_user = 'N'
  </select>
  
  <!-- Change log section -->
  <insert id="insertChangeLogEntriesRecursively" 
          parameterClass="java.util.Map">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    select <include refid="nextChangelogEntryId" />, #entry.loggerId#, #entry.loggerType#,
      #entry.operation,handler=org.vortikal.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback#, 
      #entry.timestamp#, uri, resource_id, is_collection 
    from vortex_resource 
    where uri = #entry.uri,handler=org.vortikal.repository.store.db.ibatis.PathTypeHandlerCallback# or uri like #uriWildcard# escape '@'
  </insert>


  <insert id="insertChangeLogEntryInherited" 
          parameterClass="org.vortikal.repository.ChangeLogEntry">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    select <include refid="nextChangelogEntryId" />, #loggerId#, #loggerType#,
      #operation,handler=org.vortikal.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback#, 
      #timestamp#, uri, resource_id, is_collection 
    from vortex_resource 
    where acl_inherited_from = #resourceId:NUMERIC:-1#
    or resource_id = #resourceId:NUMERIC:-1#
  </insert>


  <insert id="insertChangeLogEntryInheritedToInheritance" 
          parameterClass="java.util.Map">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    select <include refid="nextChangelogEntryId" />, #entry.loggerId#, #entry.loggerType#,
      #entry.operation,handler=org.vortikal.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback#, 
      #entry.timestamp#, vr2.uri, vr2.resource_id, vr2.is_collection 
    from vortex_resource vr1,
         vortex_resource vr2
    where vr1.resource_id = #entry.resourceId:NUMERIC:-1# 
    and (vr2.resource_id = #entry.resourceId:NUMERIC:-1#
         or (vr2.acl_inherited_from = vr1.acl_inherited_from 
             and vr2.uri like #uriWildcard# escape '@'))
  </insert>


  <insert id="insertChangeLogEntry" 
          parameterClass="org.vortikal.repository.ChangeLogEntry">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    values (<include refid="nextChangelogEntryId" />, #loggerId#, #loggerType#,
    #operation,handler=org.vortikal.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback#, 
    #timestamp#, #uri,handler=org.vortikal.repository.store.db.ibatis.PathTypeHandlerCallback#, #resourceId:NUMERIC:-1#, #collection,handler=org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback#)
  </insert>


  <!-- Comments section -->

  <resultMap id="Comment" class="java.util.HashMap">
    <result property="ID" column="ID" />
    <result property="URI" column="URI"/>
    <result property="time" column="time" jdbcType="TIMESTAMP" javaType="java.sql.Timestamp" />
    <result property="author" column="author"/>
    <result property="title" column="title"/>

    <result property="content" column="content" typeHandler="org.springframework.orm.ibatis.support.ClobStringTypeHandler" />
    <result property="approved" column="approved"
            typeHandler="org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>


  <select id="numberOfCommentsByResource"
          parameterClass="java.util.Map"
          resultClass="Integer">
    select count(c.id) as num
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id
    where r.uri = #uri#
  </select>

  <select id="listCommentsByResource"
          parameterClass="java.util.Map"
          resultMap="Comment">
    <include refid="listCommentsLimitPrepend" />
    select c.id as ID, r.uri as URI, c.time, c.author, c.title, c.content, c.approved
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id 
    where c.resource_id in
      (select resource_id from vortex_resource where uri = #uri#)
    order by c.time desc
    <include refid="listCommentsLimitAppend" />
  </select>


  <select id="listCommentsByResourceRecursively"
          parameterClass="java.util.Map"
          resultMap="Comment">
    <include refid="listCommentsLimitPrepend" />
    select c.id as ID, r.uri as URI, c.time, c.author, c.title, c.content, c.approved
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id 
    where c.resource_id in
      (select resource_id from vortex_resource where uri = #uri# or uri like #uriWildcard# escape '@')
    order by c.time desc
    <include refid="listCommentsLimitAppend" />
  </select>


  <select id="loadCommentById" parameterClass="java.lang.Integer"
          resultMap="Comment">
    select c.id as ID, #URI# as URI, c.time, c.author, c.title, c.content, c.approved
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id
    where c.id = #value#
  </select>
  

  <delete id="deleteComment" parameterClass="java.lang.Integer">
    delete from vortex_comment where id = #value#
  </delete>

  <delete id="deleteAllComments" parameterClass="org.vortikal.repository.Resource">
    delete from vortex_comment where resource_id in 
       (select resource_id from vortex_resource where uri = #URI,handler=org.vortikal.repository.store.db.ibatis.PathTypeHandlerCallback#)
  </delete>

  <!-- See: http://issues.apache.org/jira/browse/IBATIS-244 -->
  <insert id="insertComment" parameterClass="org.vortikal.repository.Comment">
    insert into vortex_comment 
      (id, resource_id, author, time, title, content, approved)
    select <include refid="nextVortexCommentId" />, r.resource_id, 
           #author.qualifiedName#, #time#, #title#, #content,handler=org.springframework.orm.ibatis.support.ClobStringTypeHandler#,
           #approved,handler=org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback#
    from vortex_resource r where r.uri = #URI,handler=org.vortikal.repository.store.db.ibatis.PathTypeHandlerCallback#
  </insert>

  <update id="updateComment" parameterClass="org.vortikal.repository.Comment">
    update vortex_comment
      set author = #author#,
          time = #time#,
          title = #title#,
          content = #content#,
          approved = #approved,handler=org.vortikal.repository.store.db.ibatis.BooleanCharTypeHandlerCallback#
      where id = #ID#
  </update>


  <!-- Versioning section -->


  <resultMap id="Revision" class="java.util.HashMap">
    <result property="id" column="id" />
    <result property="resourceId" column="resource_id" />
    <result property="name" column="revision_name"/>
    <result property="uid" column="user_id"/>
    <result property="timestamp" column="timestamp" jdbcType="TIMESTAMP" javaType="java.sql.Timestamp" />
    <result property="checksum" column="checksum" />
    <result property="changeAmount" column="change_amount" />
  </resultMap>

  <resultMap id="RevisionAclEntry" class="java.util.HashMap">
    <result property="id" column="id" javaType="int" />
    <result property="revisionId" column="revision_id" javaType="long" />
    <result property="action" column="action_type" />
    <result property="principal" column="user_or_group_name" />
    <result property="isUser" column="is_user" />
  </resultMap>


  <select id="nextRevisionID" resultClass="Long">
    select <include refid="nextContentRevisionID" />
  </select>

  <insert id="insertRevision" parameterClass="java.util.Map">
    insert into simple_content_revision
      (id, resource_id, revision_name, user_id, timestamp, checksum, change_amount)
    values (#revisionId#, #resourceId#, #name#, #uid#, #timestamp#, #checksum#, #changeAmount#)
  </insert>

  <update id="updateRevision" parameterClass="java.util.Map">
     update simple_content_revision
      set revision_name = #name#,
          user_id = #uid#,
          timestamp = #timestamp#,
          checksum = #checksum#,
          change_amount = #changeAmount#
      where id = #revisionId# and resource_id = #resourceId#
  </update>

  <delete id="deleteRevision" parameterClass="java.util.Map">
    delete from simple_content_revision where id = #revisionId# and resource_id = #resourceId#
  </delete>

  <select id="listRevisionsByResource" parameterClass="java.util.Map" resultMap="Revision">
    select id, resource_id, revision_name, user_id, timestamp, checksum, change_amount
         from simple_content_revision where resource_id = #resourceId#
         order by timestamp desc
  </select>

  <select id="listRevisionsByResourceIds" parameterClass="java.util.Map" resultClass="Long">
    select distinct resource_id from simple_content_revision
    where resource_id in 
    <iterate prepend="" property="resourceIds" open="(" close=")" conjunction=","> 
             #resourceIds[]# 
    </iterate> 
  </select>

  <insert id="insertRevisionAclEntry" parameterClass="java.util.Map">
    insert into revision_acl_entry
      (id, action_type_id, revision_id, user_or_group_name,
       is_user, granted_by_user_name, granted_date)
    values (<include refid="nextRevisionAclEntryId" />, #actionId#, #revisionId#, #principal#,
            #isUser#, #grantedBy#, #grantedDate#)
  </insert>

  <select id="listRevisionAclEntriesByResource" parameterClass="java.util.Map" resultMap="RevisionAclEntry">
    select a.id, t.name as action_type, a.revision_id, a.user_or_group_name, a.is_user, a.granted_by_user_name, a.granted_date
    from revision_acl_entry a
      inner join action_type t on a.action_type_id = t.action_type_id
    where a.revision_id in
       (select id from simple_content_revision where resource_id = #resourceId#)
  </select>

  <!-- System index DAO statement section -->
  <select id="nextTempTableSessionId" resultClass="java.lang.Integer">
    select <include refid="nextTempTableSessionId" />
  </select>
  
  <insert id="insertUriIntoTempTable" parameterClass="java.util.Map">
    insert into vortex_tmp(session_id, uri) values (#sessionId#, #uri#)
  </insert>
  
  <!--  TODO: Column vortex_tmp.resource_id should be renamed to vortex_tmp.generic_id -->
  <insert id="insertChangelogEntryIdIntoTempTable" parameterClass="java.util.Map">
    insert into vortex_tmp(session_id, resource_id) values (#sessionId#, #changelogEntryId#)
  </insert>
  
  <insert id="insertResourceIdIntoTempTable" parameterClass="java.util.Map">
    insert into vortex_tmp(session_id, resource_id) values (#sessionId#, #resourceId#)
  </insert>
  
  <delete id="deleteFromTempTableBySessionId" parameterClass="java.lang.Integer">
    delete from vortex_tmp where session_id = #value#
  </delete>
  
  <select id="orderedPropertySetIteration" resultMap="ResourceAndExtraProperties">
    select r.*, 
    p.name_space,
    p.name,
    p.value,
    case when p.binary_content is null then 'N' else 'Y' end as is_binary,
    p.is_inherited
    from vortex_resource r
    left outer join extra_prop_entry p on r.resource_id = p.resource_id
    where r.uri like '/%'
    order by r.uri, p.extra_prop_entry_id
  </select>
  
  <select id="orderedPropertySetIterationWithStartUri" parameterClass="java.util.Map"
                                                       resultMap="ResourceAndExtraProperties">
    select r.*,
           p.name_space,
           p.name,
           p.value,
           case when p.binary_content is null then 'N' else 'Y' end as is_binary,
           p.is_inherited
           from vortex_resource r
    left outer join extra_prop_entry p  on r.resource_id = p.resource_id
    where r.uri = #uri# or r.uri like #uriWildcard#
    escape '@' order by r.uri, p.extra_prop_entry_id
  </select>

  <select id="orderedPropertySetIterationForUris" parameterClass="java.lang.Integer"
                                                  resultMap="ResourceAndExtraProperties">
    select r.*,
           p.name_space,
           p.name,
           p.value,
           case when p.binary_content is null then 'N' else 'Y' end as is_binary,
           p.is_inherited
       from vortex_tmp t, vortex_resource r
       left outer join extra_prop_entry p on r.resource_id = p.resource_id
       where r.uri = t.uri AND t.session_id=#value#
       order by p.resource_id, p.extra_prop_entry_id
  </select>

  <select id="getAclReadPrincipalNames" resultMap="Principal"
                                        parameterClass="java.lang.Integer">
    select user_or_group_name, is_user from acl_entry
    where resource_id = #value#
      and action_type_id in (1, 2, 3, 4)
  </select>
  
  <delete id="removeChangelogEntriesByTempTable" parameterClass="java.lang.Integer">
    delete from changelog_entry 
      where changelog_entry_id in (select resource_id from vortex_tmp where session_id=#value#)
  </delete>

  <select id="getChangeLogEntries" parameterClass="java.util.Map" 
                                   resultMap="ChangeLogEntry">
    <isNotNull property="limit">
      <!--  Needed for Oracle, renders to empty string by default. -->
      <include refid="limitPrepend"/>
    </isNotNull>
    select * from changelog_entry
      where logger_type=#loggerType# and logger_id=#loggerId# 
      order by changelog_entry_id
    <isNotNull property="limit" >
       <include refid="limitAppend"/>
    </isNotNull>
  </select>

</sqlMap>
