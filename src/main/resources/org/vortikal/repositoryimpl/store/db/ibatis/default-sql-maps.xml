<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sqlMap PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN" 
                 "http://ibatis.apache.org/dtd/sql-map-2.dtd"> 

<sqlMap>

  <resultMap id="Resource" class="java.util.HashMap">
    <result property="uri" column="uri" />
    <result property="id" column="resource_id" javaType="int"/>
    <result property="resourceType" column="resource_type"/>
    <result property="creationTime" column="creation_time" javaType="date"/>
    <result property="createdBy" column="created_by" />
    <result property="contentLastModified" column="content_last_modified" javaType="date"/>
    <result property="propertiesLastModified" column="properties_last_modified" javaType="date"/>
    <result property="lastModified" column="last_modified" javaType="date"/>
    <result property="contentModifiedBy" column="content_modified_by" />
    <result property="propertiesModifiedBy" column="properties_modified_by" />
    <result property="modifiedBy" column="modified_by" />
    <result property="owner" column="resource_owner" />
    <result property="contentLanguage" column="content_language" />
    <result property="contentType" column="content_type" />
    <result property="contentLength" column="content_length" javaType="long" />
    <result property="characterEncoding" column="character_encoding" />
    <result property="guessedCharacterEncoding" column="guessed_character_encoding" />
    <result property="userSpecifiedCharacterEncoding" column="user_character_encoding" />
    <result property="isCollection" column="is_collection" />
    <result property="aclInheritedFrom" column="acl_inherited_from" javaType="int" />
  </resultMap>

  <!-- TODO: Result map class can be a java.lang.String directly. 
             No need to go through a Map -->
  <resultMap id="Uri" class="java.util.HashMap">
    <result property="uri" column="uri" />
  </resultMap>


  <resultMap id="UriResourceId" class="java.util.HashMap">
    <result property="uri" column="uri" />
    <result property="resourceId" column="resource_id" javaType="int" />
  </resultMap>


  <resultMap id="ResourceIdInheritedFromMap" class="java.util.HashMap">
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="inheritedFrom" column="inherited_from" javaType="int" />
  </resultMap>


  <resultMap id="Property" class="java.util.HashMap">
    <result property="id" column="extra_prop_entry_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="type" column="prop_type" />
    <result property="typeId" column="prop_type_id" javaType="int" />
    <result property="name" column="name" />
    <result property="namespaceUri" column="name_space" />
    <result property="value" column="value" />
  </resultMap>


  <resultMap id="AclEntry" class="java.util.HashMap">
    <result property="id" column="acl_entry_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="action" column="action_type" />
    <result property="principal" column="user_or_group_name" />
    <result property="isUser" column="is_user" />
  </resultMap>


  <resultMap id="ActionType" class="java.util.HashMap">
    <result property="id" column="action_type_id" javaType="int" />
    <result property="name" column="name" />
  </resultMap>
  
  <resultMap id="UserOrGroupName" class="java.lang.String">
    <result property="userOrGroupName"/>
  </resultMap>
  
  <resultMap id="Lock" class="java.util.HashMap">
    <result property="id" column="lock_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="uri" column="uri" />
    <result property="token" column="token" />
    <result property="owner" column="lock_owner" />
    <result property="ownerInfo" column="lock_owner_info" />
    <result property="depth" column="depth" />
    <result property="timeout" column="timeout" javaType="date" />
  </resultMap>

  <resultMap id="ResourceAndExtraProperties" class="java.util.HashMap"
    extends="Resource">
    
    <!-- Some columns from 'extra_prop_entry' -->
    <result property="typeId" column="prop_type_id" javaType="int" />
    <result property="name" column="name" />
    <result property="namespace" column="name_space" />
    <result property="value" column="value" />
  </resultMap>
  
  <resultMap id="ResourceAndExtraPropertiesWithAncestorIds" class="java.util.HashMap"
    extends="ResourceAndExtraProperties">
    
    <!-- Resource ancestor ids -->
    <result property="ancestorIds" column="ancestor_ids" javaType="string"/>
  </resultMap>
  
  <!-- ChangeLog entry result mapping -->
  <resultMap id="ChangeLogEntry" class="org.vortikal.repositoryimpl.ChangeLogEntry">
    <result property="changeLogEntryId" column="changelog_entry_id" javaType="int"/>
    <result property="loggerId" column="logger_id" javaType="int"/>
    <result property="loggerType" column="logger_type" javaType="int"/>
    <result property="uri" column="uri" />
    <result property="resourceId" column="resource_id" javaType="int" nullValue="-1"/>
    <result property="operation" column="operation" 
      typeHandler="org.vortikal.repositoryimpl.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback"/>
    <result property="collection" column="is_collection"
      typeHandler="org.vortikal.repositoryimpl.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
    <result property="timestamp" column="timestamp" javaType="date"/>
  </resultMap>
  

  <select id="loadResourceByUri" resultMap="Resource">
    select * from vortex_resource where uri = #value#
  </select>


  <select id="loadResourceIdByUri" resultMap="UriResourceId">
    select uri, resource_id from vortex_resource where uri = #value#
  </select>


  <update id="updateResource" parameterClass="java.util.Map">
    update vortex_resource set
      content_last_modified = #contentLastModified#,
      properties_last_modified = #propertiesLastModified#,
      content_modified_by = #contentModifiedBy#,
      properties_modified_by = #propertiesModifiedBy#,
      resource_owner = #owner#,
      content_language = #contentLanguage#,
      content_type = #contentType#,
      character_encoding = #characterEncoding#,
      guessed_character_encoding = #guessedCharacterEncoding#,
      user_character_encoding = #userSpecifiedCharacterEncoding#,
      creation_time = #creationTime#,
      resource_type = #resourceType#,
      content_length = #contentLength#,
      created_by = #createdBy#,
      modified_by = #modifiedBy#,
      last_modified = #lastModified#
    where uri = #uri#
  </update>


  <insert id="insertResource" parameterClass="java.util.Map">
    insert into vortex_resource 
      (resource_id,
       uri,
       resource_type,
       content_length,
       depth,
       creation_time,
       content_last_modified,
       properties_last_modified,
       content_modified_by,
       properties_modified_by,
       resource_owner,
       content_language,
       content_type,
       character_encoding,
       guessed_character_encoding,
       user_character_encoding,
       is_collection,
       acl_inherited_from,
       created_by,
       modified_by,
       last_modified)

    values 
      (<include refid="nextVortexResourceId" />,
       #uri#,
       #resourceType#,
       #contentLength#,
       #depth#,
       #creationTime#,
       #contentLastModified#,
       #propertiesLastModified#,
       #contentModifiedBy#,
       #propertiesModifiedBy#,
       #owner#,
       #contentLanguage#, 
       #contentType#,
       #characterEncoding#,
       #guessedCharacterEncoding#,
       #userSpecifiedCharacterEncoding#,
       #collection#,
       #aclInheritedFrom#,
       #createdBy#,
       #modifiedBy#,
       #lastModified#)
  </insert>


  <!-- Allows overriding most of the properties by supplying values in the parameter map -->
  <insert id="copyResource" parameterClass="java.util.Map">
    insert into vortex_resource 
      (resource_id,
       uri,
       prev_resource_id,
       resource_type,
       content_length,
       depth,
       creation_time,
       content_last_modified,
       properties_last_modified,
       content_modified_by,
       properties_modified_by,
       resource_owner,
       content_language,
       content_type,
       character_encoding,
       guessed_character_encoding,
       user_character_encoding,
       is_collection,
       acl_inherited_from,
       created_by,
       modified_by,
       last_modified)

    select
      <include refid="nextVortexResourceId" />,
      <include refid="destinationUriCopy" />,
      resource_id,
      resource_type,
      content_length,
      depth + #depthDiff#,
      <isPropertyAvailable property="creationTime">#creationTime#,</isPropertyAvailable>
      <isNotPropertyAvailable property="creationTime">creation_time,</isNotPropertyAvailable>
      <isPropertyAvailable property="contentLastModified">#contentLastModified#,</isPropertyAvailable>
      <isNotPropertyAvailable property="contentLastModified">content_last_modified,</isNotPropertyAvailable>
      <isPropertyAvailable property="propertiesLastModified">#propertiesLastModified#,</isPropertyAvailable>
      <isNotPropertyAvailable property="propertiesLastModified">properties_last_modified,</isNotPropertyAvailable>
      <isPropertyAvailable property="contentModifiedBy">#contentModifiedBy#,</isPropertyAvailable>
      <isNotPropertyAvailable property="contentModifiedBy">content_modified_by,</isNotPropertyAvailable>
      <isPropertyAvailable property="propertiesModifiedBy">#propertiesModifiedBy#,</isPropertyAvailable>
      <isNotPropertyAvailable property="propertiesModifiedBy">properties_modified_by,</isNotPropertyAvailable>
      <isPropertyAvailable property="owner">#owner#,</isPropertyAvailable>
      <isNotPropertyAvailable property="owner">resource_owner,</isNotPropertyAvailable>
      <isPropertyAvailable property="contentLanguage">#contentLanguage#,</isPropertyAvailable>
      <isNotPropertyAvailable property="contentLanguage">content_language,</isNotPropertyAvailable>
      <isPropertyAvailable property="contentType">#contentType#,</isPropertyAvailable>
      <isNotPropertyAvailable property="contentType">content_type,</isNotPropertyAvailable>
      <isPropertyAvailable property="characterEncoding">#characterEncoding#,</isPropertyAvailable>
      <isNotPropertyAvailable property="characterEncoding">character_encoding,</isNotPropertyAvailable>
      <isPropertyAvailable property="guessedCharacterEncoding">#guessedCharacterEncoding#,</isPropertyAvailable>
      <isNotPropertyAvailable property="guessedCharacterEncoding">guessed_character_encoding,</isNotPropertyAvailable>
      <isPropertyAvailable property="userSpecifiedCharacterEncoding">#userSpecifiedCharacterEncoding#,</isPropertyAvailable>
      <isNotPropertyAvailable property="userSpecifiedCharacterEncoding">user_character_encoding,</isNotPropertyAvailable>
      is_collection,
      acl_inherited_from,
      <isPropertyAvailable property="createdBy">#createdBy#,</isPropertyAvailable>
      <isNotPropertyAvailable property="createdBy">created_by,</isNotPropertyAvailable>
      <isPropertyAvailable property="modifiedBy">#modifiedBy#,</isPropertyAvailable>
      <isNotPropertyAvailable property="modifiedBy">modified_by,</isNotPropertyAvailable>
      <isPropertyAvailable property="lastModified">#lastModified#</isPropertyAvailable>
      <isNotPropertyAvailable property="lastModified">last_modified</isNotPropertyAvailable>
    from vortex_resource
    where uri = #uri# or uri like #uriWildcard# escape '@'
  </insert>

  
  <update id="moveResource" parameterClass="java.util.Map">
    update vortex_resource set
        uri = #destUri#,
        depth = depth + #depthDiff#
    where uri = #srcUri#
  </update>

  <update id="moveDescendants" parameterClass="java.util.Map">
    update vortex_resource set
        uri = <include refid="destinationDescendantUriMove" />,
        depth = depth + #depthDiff#
    where uri like #uriWildcard# escape '@'
  </update>


  <delete id="deleteResourceByUri" parameterClass="java.util.Map">
    delete from vortex_resource where uri = #uri# or uri like #uriWildcard# escape '@'
  </delete>


  <select id="loadChildren" parameterClass="java.util.Map"
          resultMap="Resource">
    select * from vortex_resource where uri like #uriWildcard# escape '@' and depth = #depth#
  </select>


  <select id="loadChildUrisForChildren" parameterClass="java.util.Map"
          resultMap="Uri">
    select uri from vortex_resource where uri like #uriWildcard# escape '@' and depth = #depth# 
  </select>

  <update id="updateAclInheritedFromByResourceId" parameterClass="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #inheritedFrom#
      where resource_id = #resourceId#
  </update>


  <update id="updateAclInheritedFromByUri" parameterClass="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #inheritedFrom#
      where uri = #uri# or uri like #uriWildcard# escape '@'
  </update>


  <update id="updateAclInheritedFromByPreviousInheritedFromAndUri" parameterClass="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #inheritedFrom#
      where (uri = #uri# or uri like #uriWildcard# escape '@')
             and acl_inherited_from = #previouslyInheritedFrom#
  </update>


  <update id="updateAclInheritedFromByResourceIdOrPreviousInheritedFrom" parameterClass="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #inheritedFrom#
      where acl_inherited_from = #previouslyInheritedFrom#
        or resource_id = #resourceId#
  </update>


  <select id="loadPreviousInheritedFromMap" parameterClass="java.util.Map"
          resultMap="ResourceIdInheritedFromMap">
    select
      r1.resource_id,
      r2.resource_id as inherited_from 
    from vortex_resource r1, vortex_resource r2 
    where (r1.uri = #uri# or r1.uri like #uriWildcard# escape '@')
           and r2.prev_resource_id = r1.acl_inherited_from
  </select>


  <update id="clearPrevResourceIdByUri" parameterClass="java.util.Map">
    update vortex_resource
      set prev_resource_id = null
      where uri = #uri# or uri like #uriWildcard# escape '@'
  </update>


  <select id="loadActionTypes" resultMap="ActionType">
    select * from action_type
  </select>


  <select id="loadPropertiesForResource" parameterClass="int" resultMap="Property">
    select
      p.*,
      t.prop_type_name as prop_type
    from extra_prop_entry p
      inner join prop_type t on p.prop_type_id = t.prop_type_id
    where resource_id = #value#
    order by p.extra_prop_entry_id
  </select>


  <select id="loadPropertiesForChildren" parameterClass="java.util.Map"
          resultMap="Property">
    select
      p.*,
      t.prop_type_name as prop_type
    from extra_prop_entry p
      inner join prop_type t on p.prop_type_id = t.prop_type_id
    where p.resource_id in
      (select resource_id from vortex_resource
        where uri like #uriWildcard# escape '@' and depth = #depth#)
    order by p.resource_id, p.extra_prop_entry_id
  </select>

  <insert id="insertPropertyEntry" parameterClass="java.util.Map">
    insert into extra_prop_entry
      (extra_prop_entry_id, resource_id, prop_type_id, name_space, name, value)
    values (<include refid="nextExtraPropEntryId" />, #resourceId#, #type#,
            #namespaceUri#, #name#, #value#)
  </insert>


  <insert id="copyProperties" parameterClass="java.util.Map">
    insert into extra_prop_entry
      (extra_prop_entry_id,
       resource_id,
       prop_type_id,
       name_space,
       name,
       value)
    select
      <include refid="nextExtraPropEntryId" />, t.*
      from
        (select
          r.resource_id,
          p.prop_type_id,
          p.name_space,
          p.name,
          p.value
        from vortex_resource r inner join extra_prop_entry p 
             on r.prev_resource_id = p.resource_id
        where (r.uri = #destUri# or r.uri like #destUriWildcard# escape '@')
          and r.prev_resource_id is not null
          order by p.extra_prop_entry_id) t
  </insert>    


  <delete id="deletePropertiesByResourceId" parameterClass="int">
    delete from extra_prop_entry where resource_id = #resourceId#
  </delete>


  <delete id="deletePropertiesByUri" parameterClass="java.util.Map">
    delete from extra_prop_entry where resource_id in
      (select resource_id from vortex_resource
       where uri = #uri# or uri like #uriWildcard# escape '@')
  </delete>


  <select id="loadAclEntriesByResourceIds" resultMap="AclEntry">
    select
      r.resource_id as resource_id,
      a.*,
      t.name as action_type
    from acl_entry a
      inner join action_type t on a.action_type_id = t.action_type_id
      inner join vortex_resource r on r.resource_id = a.resource_id
    where r.resource_id in 

    <iterate prepend="" property="resourceIds" open="(" close=")" conjunction=","> 
             #resourceIds[]# 
    </iterate> 
  </select>

  
  <insert id="insertAclEntry" parameterClass="java.util.Map">
    insert into acl_entry
      (acl_entry_id, action_type_id, resource_id, user_or_group_name,
       is_user, granted_by_user_name, granted_date)
    values (<include refid="nextAclEntryId" />, #actionId#, #resourceId#, #principal#,
            #isUser#, #grantedBy#, #grantedDate#)
  </insert>

  
  <insert id="copyAclEntries" parameterClass="java.util.Map">
    insert into acl_entry
      (acl_entry_id,
       resource_id,
       action_type_id,
       user_or_group_name,
       is_user,
       granted_by_user_name,
       granted_date)
     select
       <include refid="nextAclEntryId" />,
       r.resource_id,
       a.action_type_id,
       a.user_or_group_name,
       a.is_user,
       a.granted_by_user_name,
       a.granted_date
     from vortex_resource r inner join acl_entry a
       on r.prev_resource_id = a.resource_id 
     where (r.uri = #destUri#  or r.uri like #destUriWildcard# escape '@')
            and r.prev_resource_id is not null    
  </insert>
  

  <select id="discoverAcls" parameterClass="java.util.Map" resultMap="Uri">
    select distinct
      r.uri as uri
    from acl_entry a inner join vortex_resource r on a.resource_id = r.resource_id
    where r.acl_inherited_from is null and r.resource_id in
      (select resource_id from vortex_resource where uri like #uriWildcard# escape '@')
  </select>


  <delete id="deleteAclEntriesByUri" parameterClass="java.util.Map">
    delete from acl_entry where resource_id in
      (select resource_id from vortex_resource
       where uri = #uri# or uri like #uriWildcard# escape '@')
  </delete>


  <delete id="deleteAclEntriesByResourceId" parameterClass="int">
    delete from acl_entry where resource_id = #id#
  </delete>


  <select id="isInheritedAcl" parameterClass="int" resultMap="ResourceIdInheritedFromMap">
    select
      acl_inherited_from as inherited_from, resource_id
    from vortex_resource
    where resource_id = #value#
  </select>


  <select id="findNearestAclResourceId" resultMap="UriResourceId">
    select
      r.resource_id, r.uri 
    from acl_entry a
      inner join vortex_resource r on r.resource_id = a.resource_id 
    where r.uri in 
    <iterate prepend="" property="path" open="(" close=")" conjunction=","> 
             #path[]# 
    </iterate> 
  </select>


  <select id="loadLocksForChildren" parameterClass="java.util.Map"
          resultMap="Lock">
    select
      r.uri as uri, l.*
    from vortex_resource r
      inner join vortex_lock l on r.resource_id = l.resource_id
      where l.timeout >= #timestamp# and r.resource_id in (select resource_id 
        from vortex_resource where uri like #uriWildcard# escape '@' and depth = #depth#)
  </select>


  <select id="loadLocksByUris" parameterClass="java.util.Map"
          resultMap="Lock">
    select
      r.uri as uri, l.*
    from vortex_resource r
      inner join vortex_lock l on r.resource_id = l.resource_id
      where l.timeout >= #timestamp# and r.uri in 
    <iterate prepend="" property="uris" open="(" close=")" conjunction=","> 
             #uris[]# 
    </iterate> 
  </select>


  <select id="loadLockByLockToken" parameterClass="string" resultMap="Lock">
    select
      r.uri as uri, l.*
    from vortex_resource r
      inner join vortex_lock l on r.resource_id = l.resource_id
      where l.token = #value#
  </select>


  <insert id="insertLock" parameterClass="java.util.Map">
    insert into vortex_lock
      (lock_id, token, resource_id, lock_owner,
       lock_owner_info, depth, timeout)
     values (<include refid="nextLockId" />,
            #lockToken#, #resourceId#, #owner#,
            #ownerInfo#, #depth#, #timeout#)
  </insert>


  <update id="updateLock" parameterClass="java.util.Map">
    update vortex_lock
      set lock_owner = #owner#,
          lock_owner_info = #ownerInfo#,
          depth = #depth#,
          timeout = #timeout#
      where token = #lockToken#
  </update>


  <delete id="deleteLockByResourceId" parameterClass="int">
    delete from vortex_lock where resource_id = #value#
  </delete>


  <delete id="deleteLocksByUri" parameterClass="java.util.Map">
    delete from vortex_lock where resource_id in
      (select resource_id from vortex_resource
       where uri = #uri# or uri like #uriWildcard# escape '@')
  </delete>


  <delete id="deleteExpiredLocks">
    delete from vortex_lock where timeout &lt; #value#
  </delete>


  <select id="discoverLocks" parameterClass="java.util.Map" resultMap="Uri">
    select
      r.uri from vortex_resource r
        inner join vortex_lock l on r.resource_id = l.resource_id
    where l.timeout &gt; #timestamp# and r.uri like #uriWildcard# escape '@'
  </select>
  
  <select id="discoverGroups" resultMap="UserOrGroupName">
    select distinct user_or_group_name from acl_entry where is_user = 'N'
  </select>
  
  
  <select id="listSubTree" parameterClass="java.util.Map" resultMap="Uri">
    select uri from vortex_resource where uri like #uriWildcard# escape '@'
  </select>
  
  
  <insert id="insertChangeLogEntriesRecursively" 
          parameterClass="java.util.Map">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    select <include refid="nextChangelogEntryId" />, #entry.loggerId#, #entry.loggerType#,
      #entry.operation,handler=org.vortikal.repositoryimpl.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback#, 
      #entry.timestamp#, uri, resource_id, is_collection 
    from vortex_resource 
    where uri = #entry.uri# or uri like #uriWildcard# escape '@'
  </insert>


  <insert id="insertChangeLogEntry" 
          parameterClass="org.vortikal.repositoryimpl.ChangeLogEntry">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    values (<include refid="nextChangelogEntryId" />, #loggerId#, #loggerType#,
    #operation,handler=org.vortikal.repositoryimpl.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback#, 
    #timestamp#, #uri#, #resourceId:NUMERIC:-1#, #collection,handler=org.vortikal.repositoryimpl.store.db.ibatis.BooleanCharTypeHandlerCallback#)
  </insert>



  <!-- Comments section -->

  <resultMap id="Comment" class="org.vortikal.repository.Comment">
    <result property="ID" column="ID" />
    <result property="URI" column="URI"/>
    <result property="time" column="time"/>
    <result property="author" column="author"/>
    <result property="title" column="title"/>
    <result property="content" column="content" />

    <result property="approved" column="approved"
            typeHandler="org.vortikal.repositoryimpl.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>

  <select id="listCommentsByResource"
          parameterClass="org.vortikal.repository.Resource"
          resultMap="Comment">
    select c.id as ID, #URI# as URI, c.time, c.author, c.title, c.content, c.approved
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id 
    where c.resource_id in
      (select resource_id from vortex_resource where uri = #URI#)
    order by c.time desc
  </select>

  <select id="loadCommentById" parameterClass="java.lang.Integer"
          resultMap="Comment">
    select c.id as ID, #URI# as URI, c.time, c.author, c.title, c.content, c.approved
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id
    where c.id = #value#
  </select>
  

  <delete id="deleteComment" parameterClass="org.vortikal.repository.Comment">
    delete from vortex_comment where id = #ID#
  </delete>

  <delete id="deleteAllComments" parameterClass="org.vortikal.repository.Resource">
    delete from vortex_comment where resource_id in 
       (select resource_id from vortex_resource where uri = #URI#)
  </delete>

  <!-- See: http://issues.apache.org/jira/browse/IBATIS-244 -->
  <insert id="insertComment" parameterClass="org.vortikal.repository.Comment">
    insert into vortex_comment 
      (id, resource_id, author, time, title, content, approved)
    select <include refid="nextVortexCommentId" />, r.resource_id, 
           #author#, #time#, #title#, #content#,
           #approved,handler=org.vortikal.repositoryimpl.store.db.ibatis.BooleanCharTypeHandlerCallback#
    from vortex_resource r where r.uri = #URI#
  </insert>

  <update id="updateComment" parameterClass="org.vortikal.repository.Comment">
    update vortex_comment
      set author = #author#,
          time = #time#,
          title = #title#,
          content = #content#,
          approved = #approved,handler=org.vortikal.repositoryimpl.store.db.ibatis.BooleanCharTypeHandlerCallback#
      where id = #ID#
  </update>

  <!-- System index DAO statement section -->
  <select id="nextTempTableSessionId" resultClass="java.lang.Integer">
    select <include refid="nextTempTableSessionId" />
  </select>
  
  <insert id="insertUriIntoTempTable" parameterClass="java.util.Map">
    insert into vortex_tmp(session_id, uri) values (#sessionId#, #uri#)
  </insert>
  
  <insert id="insertResourceIdIntoTempTable" parameterClass="java.util.Map">
    insert into vortex_tmp(session_id, resource_id) values (#sessionId#, #resourceId#)
  </insert>
  
  <delete id="deleteFromTempTableBySessionId" parameterClass="java.lang.Integer">
    delete from vortex_tmp where session_id = #value#
  </delete>
  
  <select id="orderedPropertySetIteration" resultMap="ResourceAndExtraProperties">
    select r.*, 
    p.prop_type_id, p.name_space, p.name, p.value from vortex_resource r
    left outer join extra_prop_entry p on r.resource_id = p.resource_id
    order by r.uri, p.extra_prop_entry_id
  </select>
  
  <select id="orderedPropertySetIterationWithStartUri" parameterClass="java.util.Map"
    resultMap="ResourceAndExtraPropertiesWithAncestorIds">
    
    select resource_ancestor_ids(r.uri) AS ancestor_ids, 
           r.*,
           p.prop_type_id,
           p.name_space,
           p.name,
           p.value from vortex_resource r
    left outer join extra_prop_entry p  on r.resource_id = p.resource_id
    where r.uri = #uri# or r.uri like #uriWildcard#
    escape '@' order by r.uri, p.extra_prop_entry_id
    
  </select>

  <select id="orderedPropertySetIterationForUris" parameterClass="java.lang.Integer"
                    resultMap="ResourceAndExtraPropertiesWithAncestorIds">
    select resource_ancestor_ids(r.uri) AS ancestor_ids, 
           r.*,
           p.prop_type_id,
           p.name_space,
           p.name,
           p.value
       from vortex_tmp t, vortex_resource r
       left outer join extra_prop_entry p on r.resource_id = p.resource_id
       where r.uri = t.uri AND t.session_id=#value#
       order by p.resource_id, p.extra_prop_entry_id            
  </select>

  <select id="queryResultAuthorization" resultClass="java.lang.Integer"
                                        parameterClass="java.util.Map">
    
    select ace.resource_id from acl_entry ace, vortex_tmp vtmp
    where ace.resource_id = vtmp.resource_id
    and vtmp.session_id = #sessionId#
    and ace.user_or_group_name in 
    ('pseudo:all'
      <isNotEmpty open="," property="principalNames" >
        'pseudo:authenticated'
      </isNotEmpty>
      <iterate open="," property="principalNames" conjunction=",">
        #principalNames[]#      
      </iterate>
    )
    and ace.action_type_id in (1, 3, 4)
    
  </select>
  
  <select id="getMaxChangeLogEntryId" parameterClass="java.util.Map"
          resultClass="java.lang.Integer">
    select max(cl.changelog_entry_id) from changelog_entry cl
    where cl.logger_type=#loggerType# and cl.logger_id=#loggerId#
  </select>

  <delete id="removeChangeLogEntries" parameterClass="java.util.Map">
    delete from changelog_entry where changelog_entry_id &lt;= #maxId#  
    and logger_type=#loggerType#
    and logger_id=#loggerId#
  </delete>

  <select id="getLastChangeLogEntries" parameterClass="java.util.Map"
          resultMap="ChangeLogEntry">  
  
  select cl1.*
  from changelog_entry cl1
  where
  cl1.operation = 'deleted' AND cl1.is_collection = 'Y'
  
  <!-- This fixes a subtle problem regarding deletion
  of collections. The difference between collection deletions
  and every other operation, is that the event doesn't map 1:1 with
  the number of affected resources, but rather 1:N. A collection deletion
  can involve many resources in a tree. 
  Therefore, we must make sure that we don't miss any of 
  these events. Only picking the very latest event for collections, 
  can result in masking earlier deletion events for collections
  whose names were the same as newly created collections.
  This will cause the indexing system to miss these important events, 
  and the old tree will remain in the index, except for the replaced parent node. 
  -->
    
  and cl1.changelog_entry_id &lt;= #maxId#
  and cl1.logger_id = #loggerId#
  and cl1.logger_type = #loggerType#
  or 
    cl1.changelog_entry_id IN 
    ( select max(cl2.changelog_entry_id)
      from changelog_entry cl2
      where cl1.uri = cl2.uri 
      and cl2.logger_id = #loggerId#
      and cl2.logger_type = #loggerType#
      and cl2.changelog_entry_id &lt;= #maxId# )
    
  order by cl1.changelog_entry_id
    <!-- 
      Changed ORDER BY to order by event id, instead of URI. It makes more sense
      to list events in the order they happened, rather than what the URI looks like.
      The URI is only an ID treated specially, and it doesn't
      necessarily need a parent URI to exist in the index. The index is not a file
      system, only a collection of documents, which happen to have an URI. 
    -->
    
  </select>  
</sqlMap>
