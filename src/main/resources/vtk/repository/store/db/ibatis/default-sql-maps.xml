<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="vtk.repository.store.db">

  <resultMap id="Resource" type="java.util.HashMap">
    <result property="uri" column="uri" typeHandler="vtk.repository.store.db.ibatis.PathTypeHandlerCallback" />
    <result property="id" column="resource_id" javaType="int"/>
    <result property="resourceType" column="resource_type"/>
    <result property="creationTime" column="creation_time" javaType="date"/>
    <result property="createdBy" column="created_by" />
    <result property="contentLastModified" column="content_last_modified" javaType="date"/>
    <result property="propertiesLastModified" column="properties_last_modified" javaType="date"/>
    <result property="lastModified" column="last_modified" javaType="date"/>
    <result property="contentModifiedBy" column="content_modified_by" />
    <result property="propertiesModifiedBy" column="properties_modified_by" />
    <result property="modifiedBy" column="modified_by" />
    <result property="owner" column="resource_owner" />
    <result property="contentType" column="content_type" />
    <result property="contentLength" column="content_length" javaType="long" />
    <result property="characterEncoding" column="character_encoding" />
    <result property="guessedCharacterEncoding" column="guessed_character_encoding" />
    <result property="userSpecifiedCharacterEncoding" column="user_character_encoding" />
    <result property="isCollection" column="is_collection" />
    <result property="aclInheritedFrom" column="acl_inherited_from" javaType="int" />
  </resultMap>


  <resultMap id="UriResourceId" type="java.util.HashMap">
    <result property="uri" column="uri" />
    <result property="resourceId" column="resource_id" javaType="int" />
  </resultMap>


  <resultMap id="ResourceIdInheritedFromMap" type="java.util.HashMap">
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="inheritedFrom" column="inherited_from" javaType="int" />
  </resultMap>


  <resultMap id="Property" type="java.util.HashMap">
    <result property="id" column="extra_prop_entry_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="name" column="name" />
    <result property="namespaceUri" column="name_space" />
    <result property="value" column="value" />
    <result property="binary" column="is_binary"
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
    <result property="inheritable" column="is_inheritable"
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>

  <resultMap id="UriAndProperty" type="java.util.HashMap">
    <result property="uri" column="uri" typeHandler="vtk.repository.store.db.ibatis.PathTypeHandlerCallback" />
    <result property="id" column="extra_prop_entry_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="name" column="name" />
    <result property="namespaceUri" column="name_space" />
    <result property="value" column="value" />
    <result property="binary" column="is_binary"
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
    <result property="inheritable" column="is_inheritable"
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>

  <!-- Used solely by SqlMapIndexDao -->
  <resultMap id="UriAndPropertyWithBinaryValue" type="java.util.HashMap">
    <result property="uri" column="uri" typeHandler="vtk.repository.store.db.ibatis.PathTypeHandlerCallback" />
    <result property="id" column="extra_prop_entry_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="name" column="name" />
    <result property="namespaceUri" column="name_space" />
    <result property="value" column="value" />
    <result property="binaryValue" column="binary_content" 
            typeHandler="vtk.repository.store.db.ibatis.BlobTypeHandler" />
    <result property="binaryMimetype" column="binary_mimetype" />
    <result property="inheritable" column="is_inheritable"
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>

  <resultMap id="AclEntry" type="java.util.HashMap">
    <result property="id" column="acl_entry_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="action" column="action_type" />
    <result property="principal" column="user_or_group_name" />
    <result property="isUser" column="is_user" />
  </resultMap>

  <resultMap id="Principal" type="java.util.HashMap">
    <result property="name" column="user_or_group_name" />
    <result property="isUser" column="is_user" 
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback" />
  </resultMap>

  <resultMap id="ActionType" type="java.util.HashMap">
    <result property="id" column="action_type_id" javaType="int" />
    <result property="name" column="name" />
  </resultMap>
  
  <resultMap id="UserOrGroupName" type="java.lang.String">
    <result property="userOrGroupName" column="user_or_group_name" />
  </resultMap>
  
  <resultMap id="Lock" type="java.util.HashMap">
    <result property="id" column="lock_id" javaType="int" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="uri" column="uri" />
    <result property="token" column="token" />
    <result property="owner" column="lock_owner" />
    <result property="ownerInfo" column="lock_owner_info" />
    <result property="depth" column="depth" />
    <result property="timeout" column="timeout" javaType="date" />
  </resultMap>

  <!-- Used solely by SqlMapIndexDao -->
  <resultMap id="ResourceAndExtraProperties" type="java.util.HashMap" extends="Resource">
    <!-- Some columns from 'extra_prop_entry' -->
    <result property="name" column="name" />
    <result property="namespace" column="name_space" />
    <result property="propId" column="extra_prop_entry_id" javaType="int" />
    <result property="value" column="value" />
    <result property="binaryValue" column="binary_content" typeHandler="vtk.repository.store.db.ibatis.BlobTypeHandler" />
    <result property="binaryMimetype" column="binary_mimetype" />
    <result property="inheritable" column="is_inheritable"
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>
  
  <!-- ChangeLog entry result mapping -->
  <resultMap id="ChangeLogEntry" type="vtk.repository.ChangeLogEntry">
    <result property="changeLogEntryId" column="changelog_entry_id" javaType="int"/>
    <result property="loggerId" column="logger_id" javaType="int"/>
    <result property="loggerType" column="logger_type" javaType="int"/>
    <result property="uri" column="uri" />
    <result property="resourceId" column="resource_id" javaType="int" />
    <result property="operation" column="operation" 
      typeHandler="vtk.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback"/>
    <result property="collection" column="is_collection"
      typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
    <result property="timestamp" column="timestamp" javaType="date"/>
  </resultMap>


  <select id="loadResourceByUri" resultMap="Resource">
    select * from vortex_resource where uri = #{value}
  </select>

  <select id="loadResourceIdByUri" resultMap="UriResourceId">
    select uri, resource_id from vortex_resource where uri = #{value}
  </select>

  <update id="updateResource" parameterType="java.util.Map">
    update vortex_resource set
      content_last_modified = #{contentLastModified},
      properties_last_modified = #{propertiesLastModified},
      content_modified_by = #{contentModifiedBy},
      properties_modified_by = #{propertiesModifiedBy},
      resource_owner = #{owner},
      content_type = #{contentType},
      character_encoding = #{characterEncoding},
      guessed_character_encoding = #{guessedCharacterEncoding},
      user_character_encoding = #{userSpecifiedCharacterEncoding},
      creation_time = #{creationTime},
      resource_type = #{resourceType},
      content_length = #{contentLength},
      created_by = #{createdBy},
      modified_by = #{modifiedBy},
      last_modified = #{lastModified}
    where uri = #{uri}
  </update>


  <insert id="insertResource" parameterType="java.util.Map">
    insert into vortex_resource 
      (resource_id,
       uri,
       resource_type,
       content_length,
       depth,
       creation_time,
       content_last_modified,
       properties_last_modified,
       content_modified_by,
       properties_modified_by,
       resource_owner,
       content_type,
       character_encoding,
       guessed_character_encoding,
       user_character_encoding,
       is_collection,
       acl_inherited_from,
       created_by,
       modified_by,
       last_modified)

    values 
      (<include refid="nextVortexResourceId" />,
       #{uri},
       #{resourceType},
       #{contentLength},
       #{depth},
       #{creationTime},
       #{contentLastModified},
       #{propertiesLastModified},
       #{contentModifiedBy},
       #{propertiesModifiedBy},
       #{owner},
<!--       #{contentLanguage}, -->
       #{contentType},
       #{characterEncoding},
       #{guessedCharacterEncoding},
       #{userSpecifiedCharacterEncoding},
       #{collection},
       #{aclInheritedFrom},
       #{createdBy},
       #{modifiedBy},
       #{lastModified})
  </insert>


  <!-- Allows overriding most of the properties by supplying values in the parameter map -->
  <insert id="copyResource" parameterType="java.util.Map">
    insert into vortex_resource 
      (resource_id,
       uri,
       prev_resource_id,
       resource_type,
       content_length,
       depth,
       creation_time,
       content_last_modified,
       properties_last_modified,
       content_modified_by,
       properties_modified_by,
       resource_owner,
       content_type,
       character_encoding,
       guessed_character_encoding,
       user_character_encoding,
       is_collection,
       acl_inherited_from,
       created_by,
       modified_by,
       last_modified)

    select
      <include refid="nextVortexResourceId" />,
      <include refid="destinationUriCopy" />,
      resource_id,
      resource_type,
      content_length,
      depth + #{depthDiff},
      <choose><when test="_parameter.containsKey('creationTime')">#{creationTime},</when><otherwise>creation_time,</otherwise></choose>
      <choose><when test="_parameter.containsKey('contentLastModified')">#{contentLastModified},</when><otherwise>content_last_modified,</otherwise></choose>
      <choose><when test="_parameter.containsKey('propertiesLastModified')">#{propertiesLastModified},</when><otherwise>properties_last_modified,</otherwise></choose>
      <choose><when test="_parameter.containsKey('contentModifiedBy')">#{contentModifiedBy},</when><otherwise>content_modified_by,</otherwise></choose>
      <choose><when test="_parameter.containsKey('propertiesModifiedBy')">#{propertiesModifiedBy},</when><otherwise>properties_modified_by,</otherwise></choose>
      <choose><when test="_parameter.containsKey('owner')">#{owner},</when><otherwise>owner,</otherwise></choose>
      <choose><when test="_parameter.containsKey('contentType')">#{contentType},</when><otherwise>content_type,</otherwise></choose>
      <choose><when test="_parameter.containsKey('characterEncoding')">#{characterEncoding},</when><otherwise>character_encoding,</otherwise></choose>
      <choose><when test="_parameter.containsKey('guessedCharacterEncoding')">#{guessedCharacterEncoding},</when><otherwise>guessed_character_encoding,</otherwise></choose>
      <choose><when test="_parameter.containsKey('userSpecifiedCharacterEncoding')">#{userSpecifiedCharacterEncoding},</when><otherwise>user_character_encoding,</otherwise></choose>
      is_collection,
      acl_inherited_from,
      <choose><when test="_parameter.containsKey('createdBy')">#{createdBy},</when><otherwise>created_by,</otherwise></choose>
      <choose><when test="_parameter.containsKey('modifiedBy')">#{modifiedBy},</when><otherwise>modified_by,</otherwise></choose>
      <choose><when test="_parameter.containsKey('lastModified')">#{lastModified}</when><otherwise>last_modified</otherwise></choose>
    from vortex_resource
    where uri = #{srcUri} or uri like #{uriWildcard} escape '@'
  </insert>

  
  <update id="moveResource" parameterType="java.util.Map">
    update vortex_resource set
        uri = #{destUri},
        depth = depth + #{depthDiff}
    where uri = #{srcUri}
  </update>

  <update id="moveDescendants" parameterType="java.util.Map">
    update vortex_resource set
        uri = <include refid="destinationDescendantUriMove" />,
        depth = depth + #{depthDiff}
    where uri like #{uriWildcard} escape '@'
  </update>


  <!-- ## DELETING ## -->
  
  <!-- ## Permanently delete ## -->
  <delete id="deleteResourceByUri" parameterType="java.util.Map">
    delete from vortex_resource where uri = #{uri} or uri like #{uriWildcard} escape '@'
  </delete>
  
  <!-- ## Mark as deleted ("put in trash can") ## -->
  <update id="markDeleted" parameterType="java.util.Map">
    update vortex_resource set
      uri = <include refid="trashCanUri" />,
      depth = depth + #{depthDiff}
      where uri = #{uri} or uri like #{uriWildcard} escape '@'
  </update>

  <insert id="insertTrashCanEntry" parameterType="java.util.Map">
    insert into deleted_resource (id, resource_trash_uri, parent_id, deleted_by, deleted_time, was_inherited_acl)
      values (<include refid="nextDeletedResourceId" />,
              #{trashCanURI}, #{parentID}, #{principal}, #{deletedTime}, #{wasInheritedAcl})
  </insert>

  <!-- ## Display recoverable resources (trash can contents) ## -->
  <resultMap id="recoverableResource" type="vtk.repository.RecoverableResource">
    <result property="id" column="id" />
    <result property="trashUri" column="resource_trash_uri" />
    <result property="parentId" column="parent_id" />
    <result property="deletedBy" column="deleted_by" />
    <result property="deletedTime" column="deleted_time" />
    <result property="wasInheritedAcl" column="was_inherited_acl" 
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback" />
    <result property="resourceType" column="resource_type" />
    <result property="contentType" column="content_type" />
    <result property="isCollection" column="is_collection"
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback" />
  </resultMap>

  <select id="getRecoverableResources" parameterType="int" resultMap="recoverableResource">
    select d.*, r.resource_type, r.content_type, r.is_collection
      from deleted_resource d, vortex_resource r
      where d.parent_id = #{value} and d.resource_trash_uri = r.uri
  </select>

  <select id="getRecoverableResourceById" parameterType="int" resultMap="recoverableResource">
    select d.*, r.resource_type, r.content_type, r.is_collection
      from deleted_resource d, vortex_resource r
      where d.id = #{value} and d.resource_trash_uri = r.uri
  </select>

  <!--  ## Recover deleted resource ## -->
  <update id="recoverResource" parameterType="java.util.Map">
    update vortex_resource set
      uri = <include refid="recoverUri" />,
      depth = depth + #{depthDiff}
      where uri like #{trashIDWildcard} escape '@'
  </update>

  <delete id="deleteFromTrashCan" parameterType="int">
    delete from deleted_resource where id = #{value}
  </delete>

  <!-- ## Permanently delete a resource that has already been marked for deletion (moved to trash can) ##-->
  <delete id="deletePermanentlyMarkDeleted" parameterType="java.util.Map">
    delete from vortex_resource where uri = #{trashCanURI} or uri like #{trashCanURIWildCard} escape '@'
  </delete>

  <!-- ## Get resources that have been deleted longer than a given limit ## -->
  <select id="getOverdue" parameterType="java.util.Date" resultMap="recoverableResource">
    select d.*, r.resource_type, r.content_type, r.is_collection
      from deleted_resource d, vortex_resource r
      where d.deleted_time &lt; #{value} and d.resource_trash_uri = r.uri
  </select>

  <!-- ## Get resources that have been deleted and are orphans (parent has been permanently deleted) ## -->
  <select id="getOrphans" resultMap="recoverableResource">
    select d.*, r.resource_type, r.content_type, r.is_collection
      from deleted_resource d, vortex_resource r
      where d.resource_trash_uri = r.uri
        and d.parent_id not in (select resource_id from vortex_resource)
  </select>

  <select id="loadChildren" parameterType="java.util.Map"
          resultMap="Resource">
    select * from vortex_resource where uri like #{uriWildcard} escape '@' and depth = #{depth}
  </select>

  <select id="loadChildUrisForChildren" parameterType="java.util.Map" resultType="vtk.repository.Path">
    select uri from vortex_resource where uri like #{uriWildcard} escape '@' and depth = #{depth} 
  </select>

  <update id="updateAclInheritedFromByResourceId" parameterType="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #{inheritedFrom}
      where resource_id = #{resourceId}
  </update>


  <update id="updateAclInheritedFromByUri" parameterType="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #{inheritedFrom}
      where uri = #{uri} or uri like #{uriWildcard} escape '@'
  </update>


  <update id="updateAclInheritedFromByPreviousInheritedFromAndUri" parameterType="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #{inheritedFrom}
      where (uri = #{uri} or uri like #{uriWildcard} escape '@')
             and acl_inherited_from = #{previouslyInheritedFrom}
  </update>


  <update id="updateAclInheritedFromByResourceIdOrPreviousInheritedFrom" parameterType="java.util.Map">
    update vortex_resource
      set acl_inherited_from = #{inheritedFrom}
      where acl_inherited_from = #{previouslyInheritedFrom}
        or resource_id = #{resourceId}
  </update>


  <select id="loadPreviousInheritedFromMap" parameterType="java.util.Map"
          resultMap="ResourceIdInheritedFromMap">
    select
      r1.resource_id,
      r2.resource_id as inherited_from 
    from vortex_resource r1, vortex_resource r2 
    where (r1.uri = #{uri} or r1.uri like #{uriWildcard} escape '@')
           and r2.prev_resource_id = r1.acl_inherited_from
  </select>


  <update id="clearPrevResourceIdByUri" parameterType="java.util.Map">
    update vortex_resource
      set prev_resource_id = null
      where uri = #{uri} or uri like #{uriWildcard} escape '@'
  </update>


  <select id="loadActionTypes" resultMap="ActionType">
    select * from action_type
  </select>


  <select id="loadPropertiesForResource" parameterType="int" resultMap="Property">
    select
      p.extra_prop_entry_id,
      p.resource_id,
      p.name,
      p.name_space,
      p.value,
      p.is_inheritable,
      case when p.binary_content is null then 'N' else 'Y' end as is_binary
    from extra_prop_entry p
    where p.resource_id = #{value}
    order by p.extra_prop_entry_id
  </select>


  <select id="loadPropertiesForChildren" parameterType="java.util.Map"
          resultMap="Property">
    select
      p.extra_prop_entry_id,
      p.resource_id,
      p.name,
      p.name_space,
      p.value,
      p.is_inheritable,
      case when p.binary_content is null then 'N' else 'Y' end as is_binary
    from extra_prop_entry p
    where p.resource_id in
      (select resource_id from vortex_resource
        where uri like #{uriWildcard} escape '@' and depth = #{depth})
    order by p.resource_id, p.extra_prop_entry_id
  </select>
  
  <select id="loadInheritableProperties" parameterType="java.util.Map"
          resultMap="UriAndProperty">
    select
      r.uri,
      p.extra_prop_entry_id,
      p.resource_id,
      p.name,
      p.name_space,
      p.value,
      p.is_inheritable,
      case when p.binary_content is null then 'N' else 'Y' end as is_binary
    from vortex_resource r inner join extra_prop_entry p on p.resource_id = r.resource_id
    where p.is_inheritable = 'Y'
          and r.uri in 
          <foreach item="uri" collection="uris" open="(" close=")" separator=",">
            #{uri, typeHandler=vtk.repository.store.db.ibatis.PathTypeHandlerCallback}
          </foreach>
    order by p.resource_id, p.extra_prop_entry_id
  </select>

  <!-- Used solely by SqlMapIndexDao -->
  <!-- TODO Can we make this parameterizable so we don't have to duplicate? 
       Result map varies as well ..-->
  <select id="loadInheritablePropertiesWithBinaryValue" parameterType="java.util.Map"
          resultMap="UriAndPropertyWithBinaryValue">
    select
      r.uri,
      p.extra_prop_entry_id,
      p.resource_id,
      p.name,
      p.name_space,
      p.value,
      p.is_inheritable,
      p.binary_content,
      p.binary_mimetype
    from vortex_resource r inner join extra_prop_entry p on p.resource_id = r.resource_id
    where p.is_inheritable = 'Y'
          and r.uri in 
          <foreach item="uri" collection="uris" open="(" close=")" separator=",">
            #{uri, typeHandler=vtk.repository.store.db.ibatis.PathTypeHandlerCallback}
          </foreach>
    order by p.resource_id, p.extra_prop_entry_id
  </select>

  <resultMap id="binaryPropertyByteArray" type="java.util.HashMap">
    <result property="byteArray" column="binary_content"
            typeHandler="vtk.repository.store.db.ibatis.BlobTypeHandler" />
  </resultMap>

  <select id="selectBinaryPropertyEntry" parameterType="java.lang.Integer"
                                         resultMap="binaryPropertyByteArray">
    select binary_content from extra_prop_entry where extra_prop_entry_id = #{value}
  </select>
  
  <select id="selectBinaryMimeTypeEntry" parameterType="java.lang.Integer" resultType="java.lang.String">
    select binary_mimetype from extra_prop_entry where extra_prop_entry_id = #{value}
  </select>
  
  <insert id="insertPropertyEntry" parameterType="java.util.Map">
    insert into extra_prop_entry
      (extra_prop_entry_id, resource_id, name_space, name, value
        <if test="_parameter.containsKey('binaryContent')">
          , binary_content, binary_mimetype
        </if>
        , is_inheritable)
    values (<include refid="nextExtraPropEntryId" />, #{resourceId}, 
      #{namespaceUri}, #{name}, #{value}
        <if test="_parameter.containsKey('binaryContent')">
          , #{binaryContent, typeHandler=vtk.repository.store.db.ibatis.BlobTypeHandler},
          #{binaryMimeType}
        </if>
        , #{inheritable, typeHandler=vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback})
  </insert>
  
  <insert id="copyProperties" parameterType="java.util.Map">
    insert into extra_prop_entry
      (extra_prop_entry_id,
       resource_id,
       name_space,
       name,
       value,
       binary_content,
       binary_mimetype,
       is_inheritable)
    select
      <include refid="nextExtraPropEntryId" />, t.*
      from
        (select
          r.resource_id,
          p.name_space,
          p.name,
          p.value,
          p.binary_content,
          p.binary_mimetype,
          p.is_inheritable
        from vortex_resource r inner join extra_prop_entry p 
             on r.prev_resource_id = p.resource_id
        where (r.uri = #{destUri} or r.uri like #{destUriWildcard} escape '@')
          and r.prev_resource_id is not null
          and not (p.name in <foreach item="prop" collection="uncopyableProperties" open="(" close=")" separator=","> 
                                    #{prop}
                             </foreach> 
                             and p.name_space is null)
          order by p.extra_prop_entry_id) t
  </insert>

  <delete id="deletePropertiesByResourceId" parameterType="int">
    delete from extra_prop_entry where resource_id = #{resourceId}
  </delete>


  <delete id="deletePropertiesByUri" parameterType="java.util.Map">
    delete from extra_prop_entry where resource_id in
      (select resource_id from vortex_resource
       where uri = #{uri} or uri like #{uriWildcard} escape '@')
  </delete>


  <select id="loadAclEntriesByResourceIds" resultMap="AclEntry">
    select
      r.resource_id as resource_id,
      a.*,
      t.name as action_type
    from acl_entry a
      inner join action_type t on a.action_type_id = t.action_type_id
      inner join vortex_resource r on r.resource_id = a.resource_id
    where r.resource_id in 

    <foreach item="id" collection="resourceIds" open="(" close=")" separator=",">
      #{id}
    </foreach>
  </select>

  
  <insert id="insertAclEntry" parameterType="java.util.Map">
    insert into acl_entry
      (acl_entry_id, action_type_id, resource_id, user_or_group_name,
       is_user, granted_by_user_name, granted_date)
    values (<include refid="nextAclEntryId" />, #{actionId}, #{resourceId}, #{principal},
            #{isUser}, #{grantedBy}, #{grantedDate})
  </insert>

  
  <insert id="copyAclEntries" parameterType="java.util.Map">
    insert into acl_entry
      (acl_entry_id,
       resource_id,
       action_type_id,
       user_or_group_name,
       is_user,
       granted_by_user_name,
       granted_date)
     select
       <include refid="nextAclEntryId" />,
       r.resource_id,
       a.action_type_id,
       a.user_or_group_name,
       a.is_user,
       a.granted_by_user_name,
       a.granted_date
     from vortex_resource r inner join acl_entry a
       on r.prev_resource_id = a.resource_id 
     where (r.uri = #{destUri}  or r.uri like #{destUriWildcard} escape '@')
            and r.prev_resource_id is not null    
  </insert>
  

  <select id="discoverAcls" parameterType="java.util.Map" resultType="vtk.repository.Path">
    select distinct
      r.uri as uri
    from acl_entry a inner join vortex_resource r on a.resource_id = r.resource_id
    where r.acl_inherited_from is null and r.resource_id in
      (select resource_id from vortex_resource where uri like #{uriWildcard} escape '@' or uri =  #{uri})
  </select>


  <delete id="deleteAclEntriesByUri" parameterType="java.util.Map">
    delete from acl_entry where resource_id in
      (select resource_id from vortex_resource
       where uri = #{uri} or uri like #{uriWildcard} escape '@')
  </delete>


  <delete id="deleteAclEntriesByResourceId" parameterType="int">
    delete from acl_entry where resource_id = #{id}
  </delete>


  <select id="isInheritedAcl" parameterType="int" resultMap="ResourceIdInheritedFromMap">
    select
      acl_inherited_from as inherited_from, resource_id
    from vortex_resource
    where resource_id = #{value}
  </select>


  <select id="findNearestAclResourceId" resultMap="UriResourceId">
    select
      r.resource_id, r.uri 
    from acl_entry a
      inner join vortex_resource r on r.resource_id = a.resource_id 
    where r.uri in 
    <foreach item="path" collection="path" open="(" close=")" separator=",">
      #{path}
    </foreach>
  </select>


  <select id="loadLocksForChildren" parameterType="java.util.Map"
          resultMap="Lock">
    select
      r.uri as uri, l.*
    from vortex_resource r
      inner join vortex_lock l on r.resource_id = l.resource_id
      where l.timeout >= #{timestamp} and r.resource_id in (select resource_id 
        from vortex_resource where uri like #{uriWildcard} escape '@' and depth = #{depth})
  </select>


  <select id="loadLocksByUris" parameterType="java.util.Map"
          resultMap="Lock">
    select
      r.uri as uri, l.*
    from vortex_resource r
      inner join vortex_lock l on r.resource_id = l.resource_id
      where l.timeout >= #{timestamp} and r.uri in 
    <foreach item="uri" collection="uris" open="(" close=")" separator=","> 
             #{uri}
    </foreach> 
  </select>


  <select id="loadLockByLockToken" parameterType="string" resultMap="Lock">
    select
      r.uri as uri, l.*
    from vortex_resource r
      inner join vortex_lock l on r.resource_id = l.resource_id
      where l.token = #{value}
  </select>


  <insert id="insertLock" parameterType="java.util.Map">
    insert into vortex_lock
      (lock_id, token, resource_id, lock_owner,
       lock_owner_info, depth, timeout)
     values (<include refid="nextLockId" />,
            #{lockToken}, #{resourceId}, #{owner},
            #{ownerInfo}, #{depth}, #{timeout})
  </insert>


  <update id="updateLock" parameterType="java.util.Map">
    update vortex_lock
      set lock_owner = #{owner},
          lock_owner_info = #{ownerInfo},
          depth = #{depth},
          timeout = #{timeout}
      where token = #{lockToken}
  </update>


  <delete id="deleteLockByResourceId" parameterType="int">
    delete from vortex_lock where resource_id = #{value}
  </delete>


  <delete id="deleteLocksByUri" parameterType="java.util.Map">
    delete from vortex_lock where resource_id in
      (select resource_id from vortex_resource
       where uri = #{uri} or uri like #{uriWildcard} escape '@')
  </delete>


  <delete id="deleteExpiredLocks">
    delete from vortex_lock where timeout &lt; #{value}
  </delete>

  <select id="discoverLocks" parameterType="java.util.Map"
                             resultType="java.lang.String">
    select
      r.uri from vortex_resource r
        inner join vortex_lock l on r.resource_id = l.resource_id
    where l.timeout &gt; #{timestamp} and r.uri like #{uriWildcard} escape '@'
  </select>
  
  <select id="discoverGroups" resultMap="UserOrGroupName">
    select user_or_group_name from acl_entry where is_user = 'N'
    union
    select user_or_group_name from revision_acl_entry where is_user = 'N'
  </select>
  
  <!-- Change log section -->
  <insert id="insertChangeLogEntriesRecursively" 
          parameterType="java.util.Map">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    select <include refid="nextChangelogEntryId" />, #{entry.loggerId}, #{entry.loggerType},
      #{entry.operation,typeHandler=vtk.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback}, 
      #{entry.timestamp}, uri, resource_id, is_collection 
    from vortex_resource 
    where uri = #{entry.uri,typeHandler=vtk.repository.store.db.ibatis.PathTypeHandlerCallback} or uri like #{uriWildcard} escape '@'
  </insert>


  <insert id="insertChangeLogEntryInherited" 
          parameterType="vtk.repository.ChangeLogEntry">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    select <include refid="nextChangelogEntryId" />, #{loggerId}, #{loggerType},
      #{operation,typeHandler=vtk.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback}, 
      #{timestamp}, uri, resource_id, is_collection 
    from vortex_resource 
    <choose>
      <when test="resourceId == null">
        where acl_inherited_from = -1
        or resource_id = -1
      </when>
      <otherwise>
        where acl_inherited_from = #{resourceId}
        or resource_id = #{resourceId}
      </otherwise>
    </choose>
  </insert>


  <insert id="insertChangeLogEntryInheritedToInheritance" 
          parameterType="java.util.Map">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    select <include refid="nextChangelogEntryId" />, #{entry.loggerId}, #{entry.loggerType},
      #{entry.operation,typeHandler=vtk.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback}, 
      #{entry.timestamp}, vr2.uri, vr2.resource_id, vr2.is_collection 
    from vortex_resource vr1,
         vortex_resource vr2
    <choose>
    <when test="entry.resourceId == null">
    where vr1.resource_id = -1 
    and (vr2.resource_id = -1
         or (vr2.acl_inherited_from = vr1.acl_inherited_from 
             and vr2.uri like #{uriWildcard} escape '@'))
    </when>
    <otherwise>
    where vr1.resource_id = #{entry.resourceId} 
    and (vr2.resource_id = #{entry.resourceId}
         or (vr2.acl_inherited_from = vr1.acl_inherited_from 
             and vr2.uri like #{uriWildcard} escape '@'))
    </otherwise>
    </choose>
  </insert>


  <insert id="insertChangeLogEntry" 
          parameterType="vtk.repository.ChangeLogEntry">
    insert into changelog_entry 
      (changelog_entry_id, logger_id, logger_type,
      operation, timestamp, uri, resource_id, is_collection)
    values (<include refid="nextChangelogEntryId" />, #{loggerId}, #{loggerType},
    #{operation, typeHandler=vtk.repository.store.db.ibatis.ChangeLogEntryOperationTypeHandlerCallback}, 
    #{timestamp}, #{uri, typeHandler=vtk.repository.store.db.ibatis.PathTypeHandlerCallback}, #{resourceId}, 
    #{collection, typeHandler=vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback})
  </insert>


  <!-- Comments section -->

  <resultMap id="Comment" type="vtk.repository.Comment">
    <result property="id" column="id" />
    <result property="uri" column="uri" />
    <result property="time" column="time" jdbcType="TIMESTAMP" javaType="java.util.Date" />
    <result property="author" column="author" />
    <result property="title" column="title" />

    <result property="content" column="content" jdbcType="CLOB" typeHandler="vtk.repository.store.db.ibatis.ClobTypeHandler" />
    <result property="approved" column="approved"
            typeHandler="vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback"/>
  </resultMap>

  <select id="numberOfCommentsByResource" resultType="java.lang.Integer">
    select count(c.id) as num
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id
    where r.uri = #{value}
  </select>

  <select id="listCommentsByResource"
          parameterType="java.util.Map"
          resultMap="Comment">
    <include refid="listCommentsLimitPrepend" />
    select c.id as ID, r.uri as URI, c.time, c.author, c.title, c.content, c.approved
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id 
    where c.resource_id in
      (select resource_id from vortex_resource where uri = #{uri})
    order by c.time desc
    <include refid="listCommentsLimitAppend" />
  </select>


  <select id="listCommentsByResourceRecursively"
          parameterType="java.util.Map"
          resultMap="Comment">
    <include refid="listCommentsLimitPrepend" />
    select c.id as ID, r.uri as URI, c.time, c.author, c.title, c.content, c.approved
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id 
    where c.resource_id in
      (select resource_id from vortex_resource where uri = #{uri} or uri like #{uriWildcard} escape '@')
    order by c.time desc
    <include refid="listCommentsLimitAppend" />
  </select>


  <select id="loadCommentById" parameterType="java.lang.Integer"
          resultMap="Comment">
    select c.id as ID, #{URI} as URI, c.time, c.author, c.title, c.content, c.approved
    from vortex_comment c inner join vortex_resource r on c.resource_id = r.resource_id
    where c.id = #{value}
  </select>
  

  <delete id="deleteComment" parameterType="java.lang.Integer">
    delete from vortex_comment where id = #{value}
  </delete>

  <delete id="deleteAllComments" parameterType="vtk.repository.Resource">
    delete from vortex_comment where resource_id in 
       (select resource_id from vortex_resource where uri = #{URI})
  </delete>

  <!-- See: http://issues.apache.org/jira/browse/IBATIS-244 -->
  <!--insert id="insertComment" parameterType="vtk.repository.Comment">
    insert into vortex_comment 
      (id, resource_id, author, time, title, content, approved)
    select <include refid="nextVortexCommentId" />, r.resource_id, 
           #{author}, #{time}, #{title},
           #{content},
           #{approved, typeHandler=vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback}
    from vortex_resource r where r.uri = #{URI, typeHandler=vtk.repository.store.db.ibatis.PathTypeHandlerCallback}
  </insert-->
  <insert id="insertComment" parameterType="vtk.repository.Comment">
    insert into vortex_comment 
      (id, resource_id, author, time, title, content, approved)
    select <include refid="nextVortexCommentId" />, r.resource_id, 
           #{author}, #{time}, #{title},
           #{content, typeHandler=vtk.repository.store.db.ibatis.ClobTypeHandler},
           #{approved,typeHandler=vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback}
    from vortex_resource r where r.uri = #{URI}
  </insert>

  <!--update id="updateComment" parameterType="vtk.repository.Comment">
    update vortex_comment
      set author = #{author, jdbcType=VARCHAR},
          time = #{time},
          title = #{title},
          content = #{content},
          approved = #{approved, typeHandler=vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback}
      where id = #{ID}
  </update-->
  <update id="updateComment" parameterType="vtk.repository.Comment">
    update vortex_comment
      set author = #{author, jdbcType=VARCHAR},
          time = #{time},
          title = #{title},
          content = #{content, typeHandler=vtk.repository.store.db.ibatis.ClobTypeHandler},
          approved = #{approved, typeHandler=vtk.repository.store.db.ibatis.BooleanCharTypeHandlerCallback}
      where id = #{ID}
  </update>


  <!-- Versioning section -->


  <resultMap id="Revision" type="java.util.HashMap">
    <result property="id" column="id" />
    <result property="resourceId" column="resource_id" />
    <result property="name" column="revision_name"/>
    <result property="uid" column="user_id"/>
    <result property="timestamp" column="timestamp" jdbcType="TIMESTAMP" javaType="java.sql.Timestamp" />
    <result property="checksum" column="checksum" />
  </resultMap>

  <resultMap id="RevisionAclEntry" type="java.util.HashMap">
    <result property="id" column="id" javaType="int" />
    <result property="revisionId" column="revision_id" javaType="long" />
    <result property="action" column="action_type" />
    <result property="principal" column="user_or_group_name" />
    <result property="isUser" column="is_user" />
  </resultMap>


  <select id="nextRevisionID" resultType="Long">
    select <include refid="nextContentRevisionID" />
  </select>

  <insert id="insertRevision" parameterType="java.util.Map">
    insert into simple_content_revision
      (id, resource_id, revision_name, user_id, timestamp, checksum)
    values (#{revisionId}, #{resourceId}, #{name}, #{uid}, #{timestamp}, #{checksum})
  </insert>

  <update id="updateRevision" parameterType="java.util.Map">
     update simple_content_revision
      set revision_name = #{name},
          user_id = #{uid},
          timestamp = #{timestamp},
          checksum = #{checksum}
      where id = #{revisionId} and resource_id = #{resourceId}
  </update>

  <delete id="deleteRevision" parameterType="java.util.Map">
    delete from simple_content_revision where id = #{revisionId} and resource_id = #{resourceId}
  </delete>

  <select id="listRevisionsByResource" parameterType="java.util.Map" resultMap="Revision">
    select id, resource_id, revision_name, user_id, timestamp, checksum
         from simple_content_revision where resource_id = #{resourceId}
         order by timestamp desc
  </select>

  <select id="listRevisionsByResourceIds" parameterType="java.util.Map" resultType="Long">
    select distinct resource_id from simple_content_revision
    where resource_id in 
    <foreach item="id" collection="resourceIds" open="(" close=")" separator=","> 
      #{id}
    </foreach> 
  </select>

  <insert id="insertRevisionAclEntry" parameterType="java.util.Map">
    insert into revision_acl_entry
      (id, action_type_id, revision_id, user_or_group_name,
       is_user, granted_by_user_name, granted_date)
    values (<include refid="nextRevisionAclEntryId" />, #{actionId}, #{revisionId}, #{principal},
            #{isUser}, #{grantedBy}, #{grantedDate})
  </insert>

  <select id="listRevisionAclEntriesByResource" parameterType="java.util.Map" resultMap="RevisionAclEntry">
    select a.id, t.name as action_type, a.revision_id, a.user_or_group_name, a.is_user, a.granted_by_user_name, a.granted_date
    from revision_acl_entry a
      inner join action_type t on a.action_type_id = t.action_type_id
    where a.revision_id in
       (select id from simple_content_revision where resource_id = #{resourceId})
  </select>

  <!-- System index DAO statement section -->
  <select id="nextTempTableSessionId" resultType="java.lang.Integer">
    select <include refid="nextTempTableSessionId" />
  </select>
  
  <insert id="insertUriIntoTempTable" parameterType="java.util.Map">
    insert into vortex_tmp(session_id, uri) values (#{sessionId}, #{uri})
  </insert>
  
  <!--  TODO: Column vortex_tmp.resource_id should be renamed to vortex_tmp.generic_id -->
  <insert id="insertChangelogEntryIdIntoTempTable" parameterType="java.util.Map">
    insert into vortex_tmp(session_id, resource_id) values (#{sessionId}, #{changelogEntryId})
  </insert>
  
  <insert id="insertResourceIdIntoTempTable" parameterType="java.util.Map">
    insert into vortex_tmp(session_id, resource_id) values (#{sessionId}, #{resourceId})
  </insert>
  
  <delete id="deleteFromTempTableBySessionId" parameterType="java.lang.Integer">
    delete from vortex_tmp where session_id = #{value}
  </delete>
  
  <!-- No binary value lazy load, used solely by SqlMapIndexDao -->
  <select id="orderedPropertySetIteration" resultMap="ResourceAndExtraProperties">
    select r.*,
    p.name_space,
    p.name,
    p.extra_prop_entry_id,
    p.value,
    p.is_inheritable,
    p.binary_content,
    p.binary_mimetype
    from vortex_resource r
    left outer join extra_prop_entry p on r.resource_id = p.resource_id
    where r.uri like '/%'
    order by r.uri, p.extra_prop_entry_id
  </select>
  
  <!-- No binary value lazy load, used solely by SqlMapIndexDao -->
  <select id="orderedPropertySetIterationWithStartUri" parameterType="java.util.Map"
                                                       resultMap="ResourceAndExtraProperties">
    select r.*,
           p.name_space,
           p.name,
           p.value,
           p.extra_prop_entry_id,
           p.is_inheritable,
           p.binary_content,
           p.binary_mimetype
           from vortex_resource r
    left outer join extra_prop_entry p  on r.resource_id = p.resource_id
    where r.uri = #{uri} or r.uri like #{uriWildcard} escape '@'
    order by r.uri, p.extra_prop_entry_id
  </select>

  <!-- FIXME This will fail when a resource has *NO* rows in extra_prop_entry, due to
  mapping of 'inheritable' field (right side of join gets all null values, while not null expected for certain columns.
  Same thing for other statements in this file.  -->
  <!-- No binary value lazy load, used solely by SqlMapIndexDao -->
  <select id="orderedPropertySetIterationForUris" parameterType="java.lang.Integer"
                                                  resultMap="ResourceAndExtraProperties">
    select r.*,
           p.name_space,
           p.name,
           p.value,
           p.extra_prop_entry_id,
           p.is_inheritable,
           p.binary_content,
           p.binary_mimetype
       from vortex_tmp t, vortex_resource r
       left outer join extra_prop_entry p on r.resource_id = p.resource_id
       where r.uri = t.uri AND t.session_id=#{value}
       order by p.resource_id, p.extra_prop_entry_id
  </select>

  <delete id="removeChangelogEntriesByTempTable" parameterType="java.lang.Integer">
    delete from changelog_entry 
      where changelog_entry_id in (select resource_id from vortex_tmp where session_id=#{value})
  </delete>

  <select id="getChangeLogEntries" parameterType="java.util.Map" 
                                   resultMap="ChangeLogEntry">
    <if test="limit != null">
      <!--  Needed for Oracle, renders to empty string by default. -->
      <include refid="limitPrepend"/>
    </if>
    select * from changelog_entry
      where logger_type=#{loggerType} and logger_id=#{loggerId} 
      order by changelog_entry_id
    <if test="limit != null">
       <include refid="limitAppend"/>
    </if>
  </select>

</mapper>
