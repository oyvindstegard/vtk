/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
(function(){var requirejs,require,define;(function(undef){var main,req,makeMap,handlers,defined={},waiting={},config={},defining={},hasOwn=Object.prototype.hasOwnProperty,aps=[].slice;function hasProp(obj,prop){return hasOwn.call(obj,prop)}function normalize(name,baseName){var nameParts,nameSegment,mapValue,foundMap,foundI,foundStarMap,starI,i,j,part,baseParts=baseName&&baseName.split("/"),map=config.map,starMap=(map&&map["*"])||{};if(name&&name.charAt(0)==="."){if(baseName){baseParts=baseParts.slice(0,baseParts.length-1);name=baseParts.concat(name.split("/"));for(i=0;i<name.length;i+=1){part=name[i];if(part==="."){name.splice(i,1);i-=1}else{if(part===".."){if(i===1&&(name[2]===".."||name[0]==="..")){break}else{if(i>0){name.splice(i-1,2);i-=2}}}}}name=name.join("/")}else{if(name.indexOf("./")===0){name=name.substring(2)}}}if((baseParts||starMap)&&map){nameParts=name.split("/");for(i=nameParts.length;i>0;i-=1){nameSegment=nameParts.slice(0,i).join("/");if(baseParts){for(j=baseParts.length;j>0;j-=1){mapValue=map[baseParts.slice(0,j).join("/")];if(mapValue){mapValue=mapValue[nameSegment];if(mapValue){foundMap=mapValue;foundI=i;break}}}}if(foundMap){break}if(!foundStarMap&&starMap&&starMap[nameSegment]){foundStarMap=starMap[nameSegment];starI=i}}if(!foundMap&&foundStarMap){foundMap=foundStarMap;foundI=starI}if(foundMap){nameParts.splice(0,foundI,foundMap);name=nameParts.join("/")}}return name}function makeRequire(relName,forceSync){return function(){return req.apply(undef,aps.call(arguments,0).concat([relName,forceSync]))}}function makeNormalize(relName){return function(name){return normalize(name,relName)}}function makeLoad(depName){return function(value){defined[depName]=value}}function callDep(name){if(hasProp(waiting,name)){var args=waiting[name];delete waiting[name];defining[name]=true;main.apply(undef,args)}if(!hasProp(defined,name)&&!hasProp(defining,name)){throw new Error("No "+name)}return defined[name]}function splitPrefix(name){var prefix,index=name?name.indexOf("!"):-1;if(index>-1){prefix=name.substring(0,index);name=name.substring(index+1,name.length)}return[prefix,name]}makeMap=function(name,relName){var plugin,parts=splitPrefix(name),prefix=parts[0];name=parts[1];if(prefix){prefix=normalize(prefix,relName);plugin=callDep(prefix)}if(prefix){if(plugin&&plugin.normalize){name=plugin.normalize(name,makeNormalize(relName))}else{name=normalize(name,relName)}}else{name=normalize(name,relName);parts=splitPrefix(name);prefix=parts[0];name=parts[1];if(prefix){plugin=callDep(prefix)}}return{f:prefix?prefix+"!"+name:name,n:name,pr:prefix,p:plugin}};function makeConfig(name){return function(){return(config&&config.config&&config.config[name])||{}}}handlers={require:function(name){return makeRequire(name)},exports:function(name){var e=defined[name];if(typeof e!=="undefined"){return e}else{return(defined[name]={})}},module:function(name){return{id:name,uri:"",exports:defined[name],config:makeConfig(name)}}};main=function(name,deps,callback,relName){var cjsModule,depName,ret,map,i,args=[],usingExports;relName=relName||name;if(typeof callback==="function"){deps=!deps.length&&callback.length?["require","exports","module"]:deps;for(i=0;i<deps.length;i+=1){map=makeMap(deps[i],relName);depName=map.f;if(depName==="require"){args[i]=handlers.require(name)}else{if(depName==="exports"){args[i]=handlers.exports(name);usingExports=true}else{if(depName==="module"){cjsModule=args[i]=handlers.module(name)}else{if(hasProp(defined,depName)||hasProp(waiting,depName)||hasProp(defining,depName)){args[i]=callDep(depName)}else{if(map.p){map.p.load(map.n,makeRequire(relName,true),makeLoad(depName),{});args[i]=defined[depName]}else{throw new Error(name+" missing "+depName)}}}}}}ret=callback.apply(defined[name],args);if(name){if(cjsModule&&cjsModule.exports!==undef&&cjsModule.exports!==defined[name]){defined[name]=cjsModule.exports}else{if(ret!==undef||!usingExports){defined[name]=ret}}}}else{if(name){defined[name]=callback}}};requirejs=require=req=function(deps,callback,relName,forceSync,alt){if(typeof deps==="string"){if(handlers[deps]){return handlers[deps](callback)}return callDep(makeMap(deps,callback).f)}else{if(!deps.splice){config=deps;if(callback.splice){deps=callback;callback=relName;relName=null}else{deps=undef}}}callback=callback||function(){};if(typeof relName==="function"){relName=forceSync;forceSync=alt}if(forceSync){main(undef,deps,callback,relName)}else{setTimeout(function(){main(undef,deps,callback,relName)},4)}return req};req.config=function(cfg){config=cfg;if(config.deps){req(config.deps,config.callback)}return req};define=function(name,deps,callback){if(!deps.splice){callback=deps;deps=[]}if(!hasProp(defined,name)&&!hasProp(waiting,name)){waiting[name]=[name,deps,callback]}};define.amd={jQuery:true}}());define("almond",function(){});define("mout/lang/kindOf",["require","exports","module"],function(require,exports,module){var _rKind=/^\[object (.*)\]$/,_toString=Object.prototype.toString,UNDEF;function kindOf(val){if(val===null){return"Null"}else{if(val===UNDEF){return"Undefined"}else{return _rKind.exec(_toString.call(val))[1]}}}module.exports=kindOf});define("mout/lang/isKind",["require","exports","module","./kindOf"],function(require,exports,module){var kindOf=require("./kindOf");function isKind(val,kind){return kindOf(val)===kind}module.exports=isKind});define("mout/lang/isBoolean",["require","exports","module","./isKind"],function(require,exports,module){var isKind=require("./isKind");function isBoolean(val){return isKind(val,"Boolean")}module.exports=isBoolean});define("mout/array/indexOf",["require","exports","module"],function(require,exports,module){function indexOf(arr,item,fromIndex){fromIndex=fromIndex||0;var n=arr.length,i=fromIndex<0?n+fromIndex:fromIndex;while(i<n){if(arr[i]===item){return i}i+=1}return -1}module.exports=indexOf});define("mout/array/forEach",["require","exports","module"],function(require,exports,module){function forEach(arr,callback,thisObj){if(arr==null){return}var i=-1,n=arr.length;while(++i<n){if(callback.call(thisObj,arr[i],i,arr)===false){break}}}module.exports=forEach});define("mout/function/prop",["require","exports","module"],function(require,exports,module){function prop(name){return function(obj){return obj[name]}}module.exports=prop});define("mout/object/hasOwn",["require","exports","module"],function(require,exports,module){function hasOwn(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop)}module.exports=hasOwn});define("mout/object/forIn",["require","exports","module"],function(require,exports,module){var _hasDontEnumBug,_dontEnums;function checkDontEnum(){_dontEnums=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"];_hasDontEnumBug=true;for(var key in {"toString":null}){_hasDontEnumBug=false}}function forIn(obj,fn,thisObj){var key,i=0;if(_hasDontEnumBug==null){checkDontEnum()}for(key in obj){if(exec(fn,obj,key,thisObj)===false){break}}if(_hasDontEnumBug){while(key=_dontEnums[i++]){if(obj[key]!==Object.prototype[key]){if(exec(fn,obj,key,thisObj)===false){break}}}}}function exec(fn,obj,key,thisObj){return fn.call(thisObj,obj[key],key,obj)}module.exports=forIn});define("mout/object/forOwn",["require","exports","module","./hasOwn","./forIn"],function(require,exports,module){var hasOwn=require("./hasOwn");var forIn=require("./forIn");function forOwn(obj,fn,thisObj){forIn(obj,function(val,key){if(hasOwn(obj,key)){return fn.call(thisObj,obj[key],key,obj)}})}module.exports=forOwn});define("mout/object/matches",["require","exports","module","./forOwn"],function(require,exports,module){var forOwn=require("./forOwn");function matches(target,props){var result=true;forOwn(props,function(val,key){if(target[key]!==val){return(result=false)}});return result}module.exports=matches});define("mout/function/makeIterator_",["require","exports","module","./prop","../object/matches"],function(require,exports,module){var prop=require("./prop");var matches=require("../object/matches");function makeIterator(src){switch(typeof src){case"object":return(src!=null)?function(val,key,target){return matches(val,src)}:src;case"string":case"number":return prop(src);default:return src}}module.exports=makeIterator});define("mout/array/filter",["require","exports","module","./forEach","../function/makeIterator_"],function(require,exports,module){var forEach=require("./forEach");var makeIterator=require("../function/makeIterator_");function filter(arr,callback,thisObj){callback=makeIterator(callback);var results=[];forEach(arr,function(val,i,arr){if(callback.call(thisObj,val,i,arr)){results.push(val)}});return results}module.exports=filter});define("mout/array/unique",["require","exports","module","./indexOf","./filter"],function(require,exports,module){var indexOf=require("./indexOf");var filter=require("./filter");function unique(arr){return filter(arr,isUnique)}function isUnique(item,i,arr){return indexOf(arr,item,i+1)===-1}module.exports=unique});define("mout/array/every",["require","exports","module","../function/makeIterator_"],function(require,exports,module){var makeIterator=require("../function/makeIterator_");function every(arr,callback,thisObj){callback=makeIterator(callback);var result=true,i=-1,n=arr.length;while(++i<n){if(!callback.call(thisObj,arr[i],i,arr)){result=false;break}}return result}module.exports=every});define("mout/array/contains",["require","exports","module","./indexOf"],function(require,exports,module){var indexOf=require("./indexOf");function contains(arr,val){return indexOf(arr,val)!==-1}module.exports=contains});define("mout/array/intersection",["require","exports","module","./unique","./filter","./every","./contains"],function(require,exports,module){var unique=require("./unique");var filter=require("./filter");var every=require("./every");var contains=require("./contains");function intersection(arr){var arrs=Array.prototype.slice.call(arguments,1),result=filter(unique(arr),function(needle){return every(arrs,function(haystack){return contains(haystack,needle)})});return result}module.exports=intersection});define("mout/array/compact",["require","exports","module","./filter"],function(require,exports,module){var filter=require("./filter");function compact(arr){return filter(arr,function(val){return(val!=null)})}module.exports=compact});define("mout/array/remove",["require","exports","module","./indexOf"],function(require,exports,module){var indexOf=require("./indexOf");function remove(arr,item){var idx=indexOf(arr,item);if(idx!==-1){arr.splice(idx,1)}}module.exports=remove});define("mout/object/keys",["require","exports","module","./forOwn"],function(require,exports,module){var forOwn=require("./forOwn");var keys=Object.keys||function(obj){var keys=[];forOwn(obj,function(val,key){keys.push(key)});return keys};module.exports=keys});define("mout/object/size",["require","exports","module","./forOwn"],function(require,exports,module){var forOwn=require("./forOwn");function size(obj){var count=0;forOwn(obj,function(){count++});return count}module.exports=size});define("lib/functionMeta",[],function(){function functionMeta(func,name){var matches=/^function(\s+[a-zA-Z0-9_\$]*)*\s*\(([^\(]*)\)/m.exec(func.toString()),ret,split,optionalReached=false,length,x;if(!matches){return null}split=(matches[2]||"").split(/\s*,\s*/gm);length=split.length;ret={mandatory:0,optional:0,signature:""};if(split[0]!==""){for(x=0;x<length;x+=1){if(split[x].charAt(0)==="$"){ret.optional+=1;ret.signature+=split[x]+", ";optionalReached=true}else{if(!optionalReached){ret.mandatory+=1;ret.signature+=split[x]+", "}else{return null}}}ret.signature=ret.signature.substr(0,ret.signature.length-2)}if(name){if(name.charAt(0)==="_"){if(name.charAt(1)==="_"){ret.isPrivate=true}else{ret.isProtected=true}}else{ret.isPublic=true}}return ret}return functionMeta});define("mout/lang/isNumber",["require","exports","module","./isKind"],function(require,exports,module){var isKind=require("./isKind");function isNumber(val){return isKind(val,"Number")}module.exports=isNumber});define("mout/lang/isString",["require","exports","module","./isKind"],function(require,exports,module){var isKind=require("./isKind");function isString(val){return isKind(val,"String")}module.exports=isString});define("lib/isImmutable",["mout/lang/isNumber","mout/lang/isString","mout/lang/isBoolean"],function(isNumber,isString,isBoolean){function isImmutable(value){return value==null||isBoolean(value)||isNumber(value)||isString(value)}return isImmutable});define("lib/propertyMeta",["./isImmutable"],function(isImmutable){function propertyMeta(prop,name){var ret={};if(prop===undefined){return null}if(name){if(name.charAt(0)==="_"){if(name.charAt(1)==="_"){ret.isPrivate=true}else{ret.isProtected=true}}else{ret.isPublic=true}}ret.isImmutable=isImmutable(prop);return ret}return propertyMeta});define("lib/isFunctionCompatible",[],function(){function isFunctionCompatible(func1,func2){return func1.mandatory===func2.mandatory&&func1.optional>=func2.optional}return isFunctionCompatible});define("mout/array/append",["require","exports","module"],function(require,exports,module){function append(arr1,arr2){var pad=arr1.length,i=-1,n=arr2.length;while(++i<n){arr1[pad+i]=arr2[i]}return arr1}module.exports=append});define("lib/checkKeywords",["mout/object/hasOwn","mout/array/append"],function(hasOwn,append){var reservedNormal=["$constructor","$initializing","$static","$self","$super","$underStrict"],reservedAll=append(["initialize"],reservedNormal),reservedStatics=["$parent","$super","$self","$static","extend"];function checkKeywords(object,type){var reserved=type==="normal"||!type?reservedNormal:(type==="all"?reservedAll:reservedStatics),x;for(x=reserved.length-1;x>=0;x-=1){if(hasOwn(object,reserved[x])){throw new Error('"'+object.$name+'" is using a reserved keyword: '+reserved[x])}}}return checkKeywords});define("mout/array/some",["require","exports","module","../function/makeIterator_"],function(require,exports,module){var makeIterator=require("../function/makeIterator_");function some(arr,callback,thisObj){callback=makeIterator(callback);var result=false,i=-1,n=arr.length;while(++i<n){if(callback.call(thisObj,arr[i],i,arr)){result=true;break}}return result}module.exports=some});define("mout/array/difference",["require","exports","module","./unique","./filter","./some","./contains"],function(require,exports,module){var unique=require("./unique");var filter=require("./filter");var some=require("./some");var contains=require("./contains");function difference(arr){var arrs=Array.prototype.slice.call(arguments,1),result=filter(unique(arr),function(needle){return !some(arrs,function(haystack){return contains(haystack,needle)})});return result}module.exports=difference});define("lib/testKeywords",["mout/array/difference","mout/object/hasOwn"],function(difference,hasOwn){var keywords=["$name","$extends","$implements","$borrows","$statics","$finals","$abstracts","$constants"];function testKeywords(object,allowed){var test=allowed?difference(keywords,allowed):keywords,x;for(x=test.length-1;x>=0;x-=1){if(hasOwn(object,test[x])){return test[x]}}return false}return testKeywords});define("mout/lang/isFunction",["require","exports","module","./isKind"],function(require,exports,module){var isKind=require("./isKind");function isFunction(val){return isKind(val,"Function")}module.exports=isFunction});define("lib/hasDefineProperty",["mout/lang/isFunction"],function(isFunction){function hasDefineProperty(){if(!isFunction(Object.defineProperty)){return false}try{Object.defineProperty({},"x",{})}catch(e){return false}return true}return hasDefineProperty()});define("lib/isObjectPrototypeSpoiled",[],function(){function isObjectPrototypeSpoiled(){var obj={},key;for(key in obj){if(key){return true}}return false}return isObjectPrototypeSpoiled});define("lib/checkObjectPrototype",["./isObjectPrototypeSpoiled","mout/lang/isFunction"],function(isObjectPrototypeSpoiled,isFunction){function checkObjectPrototype(){if(isObjectPrototypeSpoiled()){throw new Error("dejavu will not work properly if Object.prototype has enumerable properties!")}if(isFunction(Object.seal)&&!Object.isSealed(Object.prototype)){Object.seal(Object.prototype)}}return checkObjectPrototype});define("lib/randomAccessor",["mout/array/contains"],function(contains){var random,allowed=["ClassWrapper","InterfaceWrapper","AbstractClassWrapper","FinalClassWrapper","instanceOfWrapper","inspectWrapper"],nrAllowed=allowed.length,nrAccesses=0;if(!(typeof window!=="undefined"&&window.navigator&&window.document)){random=process.pid}else{random=new Date().getTime()+"_"+Math.floor((Math.random()*100000000+1))}function randomAccessor(caller){if(nrAccesses>nrAllowed||!contains(allowed,caller)){throw new Error("Can't access random identifier.")}nrAccesses+=1;return random}return randomAccessor});define("options",[],function(){return{locked:true}});define("mout/object/mixIn",["require","exports","module","./forOwn"],function(require,exports,module){var forOwn=require("./forOwn");function mixIn(target,objects){var i=0,n=arguments.length,obj;while(++i<n){obj=arguments[i];if(obj!=null){forOwn(obj,copyProp,target)}}return target}function copyProp(val,key){this[key]=val}module.exports=mixIn});define("mout/lang/createObject",["require","exports","module","../object/mixIn"],function(require,exports,module){var mixIn=require("../object/mixIn");function createObject(parent,props){function F(){}F.prototype=parent;return mixIn(new F(),props)}module.exports=createObject});define("mout/lang/isObject",["require","exports","module","./isKind"],function(require,exports,module){var isKind=require("./isKind");function isObject(val){return isKind(val,"Object")}module.exports=isObject});define("mout/lang/isArray",["require","exports","module","./isKind"],function(require,exports,module){var isKind=require("./isKind");var isArray=Array.isArray||function(val){return isKind(val,"Array")};module.exports=isArray});define("lib/inspect",["./randomAccessor","./hasDefineProperty","mout/lang/createObject","mout/lang/isObject","mout/lang/isArray","mout/lang/isFunction","mout/object/hasOwn"],function(randomAccessor,hasDefineProperty,createObject,isObject,isArray,isFunction,hasOwn){var random=randomAccessor("inspectWrapper"),$class="$class_"+random,$wrapped="$wrapped_"+random,cacheKeyword="$cache_"+random,redefinedCacheKeyword="$redefined_cache_"+random,prev,tmp;if(!Function.prototype.bind){Function.prototype.bind=function(context){var fn=this,args=Array.prototype.slice.call(arguments,1);return function(){return fn.apply(context,Array.prototype.concat.apply(args,arguments))}}}function fetchCache(target,cache){var x,length=cache.length,curr;for(x=0;x<length;x+=1){curr=cache[x];if(curr.target===target){return curr.inspect}}return null}function inspectInstance(target,cache){if(!hasDefineProperty){return target}var def,simpleConstructor,methodsCache,propertiesCache,obj,tmp,key;obj=fetchCache(target,cache.instances);if(obj){return obj}def=target.$static[$class];simpleConstructor=def.simpleConstructor;methodsCache=target[cacheKeyword].methods;propertiesCache=target[cacheKeyword].properties;obj=createObject(simpleConstructor.prototype);cache.instances.push({target:target,inspect:obj});for(key in target[redefinedCacheKeyword].methods){obj[key]=inspect(methodsCache[key],cache,true)}for(key in target[redefinedCacheKeyword].properties){tmp=hasOwn(propertiesCache,key)?propertiesCache[key]:target[key];obj[key]=inspect(tmp,cache,true)}methodsCache=def.methods;propertiesCache=def.properties;for(key in target){if(hasOwn(target,key)&&!hasOwn(obj,key)&&!propertiesCache[key]&&!methodsCache[key]){obj[key]=inspect(target[key],cache,true)}}tmp=obj.constructor.$constructor;while(tmp){inspectConstructor(tmp,cache,true);tmp=tmp.$parent}return obj}function inspectConstructor(target,cache){if(!hasDefineProperty){return target}var def,methodsCache,propertiesCache,membersCache,obj,tmp,key;obj=fetchCache(target,cache.constructors);if(obj){return obj}def=target[$class];obj=def.simpleConstructor;methodsCache=target[cacheKeyword].methods;propertiesCache=target[cacheKeyword].properties;cache.constructors.push({target:target,inspect:obj});for(key in methodsCache){obj[key]=inspect(methodsCache[key],cache,true)}for(key in propertiesCache){tmp=propertiesCache[key];obj[key]=inspect(tmp,cache,true)}methodsCache=def.methods;propertiesCache=def.properties;for(key in target){if(hasOwn(target,key)&&!hasOwn(obj,key)&&!propertiesCache[key]&&!methodsCache[key]){obj[key]=inspect(target[key],cache,true)}}obj=obj.prototype;target=target.prototype;membersCache=def.ownMembers;methodsCache=def.methods;propertiesCache=def.properties;for(key in membersCache){tmp=methodsCache[key]?methodsCache[key].implementation:propertiesCache[key].value;obj[key]=inspect(tmp,cache,true)}for(key in target){if(hasOwn(target,key)&&!hasOwn(obj,key)&&!membersCache[key]){obj[key]=inspect(target[key],cache,true)}}return obj}function inspect(prop,cache,clone){var key,x,length,ret;cache=cache||{others:[],instances:[],constructors:[]};if(isObject(prop)){if(prop.$static){return inspectInstance(prop,cache)}ret=fetchCache(prop,cache.others);if(ret){return ret}ret={};cache.others.push({target:prop,inspect:ret});for(key in prop){ret[key]=inspect(prop[key],cache,clone)}return ret}if(isArray(prop)){ret=fetchCache(prop,cache.others);if(ret){return ret}ret=[];cache.others.push({target:prop,inspect:ret});length=prop.length;for(x=0;x<length;x+=1){ret.push(inspect(prop[x],cache,clone))}return ret}if(isFunction(prop)){if(prop[$class]){return inspectConstructor(prop,cache)}return prop[$wrapped]||prop}return prop}if(typeof console==="object"&&(!console.inspect||!console.inspect.dejavu)){tmp=typeof navigator!=="undefined"&&/msie/i.test(navigator.userAgent)&&!/opera/i.test(navigator.userAgent);prev=console.inspect||(tmp?console.dir||console.log:console.log);if(typeof prev==="object"){prev=Function.prototype.call.bind(prev,console)}console.inspect=function(){var args=[],length=arguments.length,x;for(x=0;x<length;x+=1){args[x]=inspect(arguments[x])}return prev.apply(console,args)};console.inspect.dejavu=true}});define("lib/printWarning",[],function(){function printWarning(message){if(typeof console!=="undefined"){console.warn(message)}}return printWarning});define("lib/obfuscateProperty",["./hasDefineProperty"],function(hasDefineProperty){function obfuscateProperty(obj,key,value,isWritable,isDeletable){if(hasDefineProperty){Object.defineProperty(obj,key,{value:value,configurable:isDeletable||false,writable:isWritable||false,enumerable:false})}else{obj[key]=value}}return obfuscateProperty});define("mout/lang/isDate",["require","exports","module","./isKind"],function(require,exports,module){var isKind=require("./isKind");function isDate(val){return isKind(val,"Date")}module.exports=isDate});define("mout/lang/isRegExp",["require","exports","module","./isKind"],function(require,exports,module){var isKind=require("./isKind");function isRegExp(val){return isKind(val,"RegExp")}module.exports=isRegExp});define("mout/array/combine",["require","exports","module","./indexOf"],function(require,exports,module){var indexOf=require("./indexOf");function combine(arr1,arr2){var x,length=arr2.length;for(x=0;x<length;x++){if(indexOf(arr1,arr2[x])===-1){arr1.push(arr2[x])}}return arr1}module.exports=combine});define("mout/lang/isPlainObject",["require","exports","module"],function(require,exports,module){function isPlainObject(value){return(!!value&&typeof value==="object"&&value.constructor===Object)}module.exports=isPlainObject});define("mout/lang/clone",["require","exports","module","./kindOf","./isPlainObject","../object/mixIn"],function(require,exports,module){var kindOf=require("./kindOf");var isPlainObject=require("./isPlainObject");var mixIn=require("../object/mixIn");function clone(val){switch(kindOf(val)){case"Object":return cloneObject(val);case"Array":return cloneArray(val);case"RegExp":return cloneRegExp(val);case"Date":return cloneDate(val);default:return val}}function cloneObject(source){if(isPlainObject(source)){return mixIn({},source)}else{return source}}function cloneRegExp(r){var flags="";flags+=r.multiline?"m":"";flags+=r.global?"g":"";flags+=r.ignorecase?"i":"";return new RegExp(r.source,flags)}function cloneDate(date){return new Date(+date)}function cloneArray(arr){return arr.slice()}module.exports=clone});define("mout/lang/deepClone",["require","exports","module","./clone","../object/forOwn","./kindOf","./isPlainObject"],function(require,exports,module){var clone=require("./clone");var forOwn=require("../object/forOwn");var kindOf=require("./kindOf");var isPlainObject=require("./isPlainObject");function deepClone(val,instanceClone){switch(kindOf(val)){case"Object":return cloneObject(val,instanceClone);case"Array":return cloneArray(val,instanceClone);default:return clone(val)}}function cloneObject(source,instanceClone){if(isPlainObject(source)){var out={};forOwn(source,function(val,key){this[key]=deepClone(val,instanceClone)},out);return out}else{if(instanceClone){return instanceClone(source)}else{return source}}}function cloneArray(arr,instanceClone){var out=[],i=-1,n=arr.length,val;while(++i<n){out[i]=deepClone(arr[i],instanceClone)}return out}module.exports=deepClone});define("lib/mixIn",[],function(){function mixIn(target,objects){var x,length=arguments.length,key,curr;for(x=1;x<length;x+=1){curr=arguments[x];for(key in arguments[x]){target[key]=curr[key]}}return target}return mixIn});define("mout/function/bind",["require","exports","module"],function(require,exports,module){function slice(arr,offset){return Array.prototype.slice.call(arr,offset||0)}function bind(fn,context,args){var argsArr=slice(arguments,2);return function(){return fn.apply(context,argsArr.concat(slice(arguments)))}}module.exports=bind});define("mout/lang/toArray",["require","exports","module","./kindOf"],function(require,exports,module){var kindOf=require("./kindOf");var _win=this;function toArray(val){var ret=[],kind=kindOf(val),n;if(val!=null){if(val.length==null||kind==="String"||kind==="Function"||kind==="RegExp"||val===_win){ret[ret.length]=val}else{n=val.length;while(n--){ret[n]=val[n]}}}return ret}module.exports=toArray});define("mout/array/insert",["require","exports","module","./difference","../lang/toArray"],function(require,exports,module){var difference=require("./difference");var toArray=require("../lang/toArray");function insert(arr,rest_items){var diff=difference(toArray(arguments).slice(1),arr);if(diff.length){Array.prototype.push.apply(arr,diff)}return arr.length}module.exports=insert});define("Class",["mout/lang/isBoolean","mout/array/intersection","mout/array/unique","mout/array/compact","mout/array/remove","mout/object/keys","mout/object/size","./lib/functionMeta","./lib/propertyMeta","./lib/isFunctionCompatible","./lib/checkKeywords","./lib/testKeywords","./lib/hasDefineProperty","./lib/checkObjectPrototype","./lib/randomAccessor","./options","./lib/inspect","./lib/printWarning","./lib/obfuscateProperty","./lib/isImmutable","mout/lang/isString","mout/lang/isFunction","mout/lang/isObject","mout/lang/isArray","mout/lang/isDate","mout/lang/isRegExp","mout/lang/createObject","mout/object/hasOwn","mout/array/combine","mout/array/contains","mout/lang/deepClone","./lib/mixIn","mout/function/bind","mout/lang/toArray","mout/array/insert"],function ClassWrapper(isBoolean,intersection,unique,compact,remove,keys,size,functionMeta,propertyMeta,isFunctionCompatible,checkKeywords,testKeywords,hasDefineProperty,checkObjectPrototype,randomAccessor,options,inspect,printWarning,obfuscateProperty,isImmutable,isString,isFunction,isObject,isArray,isDate,isRegExp,createObject,hasOwn,combine,contains,deepClone,mixIn,bind,toArray,insert){checkObjectPrototype();var createClass,Class={},random=randomAccessor("ClassWrapper"),$class="$class_"+random,$interface="$interface_"+random,$abstract="$abstract_"+random,$bound="$bound_"+random,$name="$name_"+random,$anonymous="$anonymous_"+random,$wrapped="$wrapped_"+random,cacheKeyword="$cache_"+random,redefinedCacheKeyword="$redefined_cache_"+random,nextId=0,caller=null,toStringInstance,toStringConstructor,glob=typeof window!=="undefined"&&window.navigator&&window.document?window:global;function inheritPrototype(A,B){var F=function(){};F.prototype=B.prototype;A.prototype=new F();A.prototype.constructor=A}function wrapMethod(name,method,constructor,isStatic){if(method[$wrapped]){method=method[$wrapped]}var parentClass=constructor.$parent,parentSource=parentClass&&(isStatic?parentClass:parentClass.prototype),parentMeta=parentClass&&parentClass[$class][isStatic?"staticMethods":"methods"][name],parentLocked=parentClass&&parentClass[$class].locked&&!parentClass[$class].forceUnlocked,parentMethod,wrapper;if(parentMeta){if(!isStatic&&parentMeta.isPrivate&&name==="initialize"){parentMethod=callingPrivateConstructor;parentSource=null}else{parentMethod=parentMeta.implementation}}else{parentMethod=defaultSuper}wrapper=function(){var that=this==null||this===glob?{}:this,_super=that.$super,_self=that.$self,prevCaller,ret,parent;parent=parentLocked||!parentSource?parentMethod:parentSource[name];prevCaller=caller;caller={method:method,constructor:constructor,constructorId:constructor[$class].id};that.$super=parent;that.$self=constructor;try{ret=method.apply(this,arguments)}finally{that.$super=_super;that.$self=_self;caller=prevCaller}return ret};obfuscateProperty(wrapper,$wrapped,method);if(method[$name]){obfuscateProperty(wrapper,$name,method[$name])}return wrapper}function callingPrivateConstructor(){throw new Error('Cannot call parent constructor in class "'+this.$name+"\" because it's declared as private.")}function addMethod(name,method,constructor,opts){opts=opts||{};var metadata,isStatic=!!opts.isStatic,forcePublic=!!(opts.forcePublic||constructor[$class].isVanilla),isFinal,target,tmp,originalMethod,inherited;if(method[$wrapped]){method=method[$wrapped]}if(method[$name]){if(method[$name]!==name){tmp=method;method=function(){return tmp.apply(this,arguments)};obfuscateProperty(method,$name,name)}}else{obfuscateProperty(method,$name,name)}if(!isStatic&&name==="initialize"&&method.$inherited){metadata=mixIn({},constructor.$parent[$class].methods[name]);inherited=true;delete method.$inherited}else{if(opts.metadata){metadata=opts.metadata;isFinal=metadata.isFinal}else{if(method[$wrapped]){throw new Error("Cannot grab metadata from wrapped method.")}metadata=functionMeta(method,name);if(!metadata){throw new Error((isStatic?"Static method":"Method")+' "'+name+'" contains optional arguments before mandatory ones in class "'+constructor.prototype.$name+'".')}metadata.isFinal=isFinal=!!opts.isFinal;if(isStatic){if(constructor[$class].staticMethods[name]){metadata.allowed=constructor[$class].staticMethods[name].allowed}}else{if(constructor[$class].methods[name]){metadata.allowed=constructor[$class].methods[name].allowed}}}}if(forcePublic){forcePublicMetadata(metadata)}if(name==="initialize"&&method.$prefix!=null){if(method.$prefix==="_"){metadata.isProtected=true}else{if(method.$prefix==="__"){metadata.isPrivate=true}}delete method.$prefix}if(metadata.isPrivate&&isFinal){throw new Error('Private method "'+name+'" cannot be classified as final in class "'+constructor.prototype.$name+'".')}target=isStatic?constructor[$class].staticProperties:constructor[$class].properties;if(isObject(target[name])){throw new Error((isStatic?"Static method":"Method")+' "'+name+'" is overwriting a '+(isStatic?"static ":"")+'property with the same name in class "'+constructor.prototype.$name+'".')}target=isStatic?constructor[$class].staticMethods:constructor[$class].methods;if(isObject(target[name])){if(target[name].forcedPublic){forcePublicMetadata(metadata)}else{if(target[name].isPrivate&&name!=="initialize"){throw new Error("Cannot override private "+(isStatic?"static ":"")+' method "'+name+'" in class "'+constructor.prototype.$name+'".')}}if(target[name].isFinal){throw new Error('Cannot override final method "'+name+'" in class "'+constructor.prototype.$name+'".')}if(metadata.checkCompatibility&&!isFunctionCompatible(metadata,target[name])){throw new Error((isStatic?"Static method":"Method")+' "'+name+"("+metadata.signature+')" defined in abstract class "'+constructor.prototype.$name+'" overrides its ancestor but it is not compatible with its signature: "'+name+"("+target[name].signature+')".')}}target[name]=metadata;if(!isStatic){constructor[$class].ownMembers[name]=true}originalMethod=method;method=wrapMethod(name,method,constructor,isStatic);obfuscateProperty(method,$name,name);metadata.implementation=method;if(metadata.isPublic||!hasDefineProperty){target=isStatic?constructor:constructor.prototype;target[name]=method}if(originalMethod[$bound]){if(!isStatic){insert(constructor[$class].binds,name)}delete originalMethod[$bound]}if(metadata.isProtected){if(metadata.allowed){insert(metadata.allowed,constructor[$class].id)}else{metadata.allowed=[constructor[$class].id]}}else{if(metadata.isPrivate){metadata.allowed=constructor[$class].id}}}function addProperty(name,value,constructor,opts){opts=opts||{};var metadata,isStatic,isFinal,isConst,forcePublic=!!(opts.forcePublic||constructor[$class].isVanilla),target;if(opts.metadata){metadata=opts.metadata;isFinal=metadata.isFinal;isConst=metadata.isConst;isStatic=!!opts.isStatic||isConst}else{metadata=propertyMeta(value,name);if(!metadata){throw new Error('Value of property "'+name+'"  in class "'+constructor.prototype.$name+'" cannot be parsed (undefined values are not allowed).')}metadata.isFinal=isFinal=!!opts.isFinal;metadata.isConst=isConst=!!opts.isConst;isStatic=!!opts.isStatic||isConst;if(isStatic){if(constructor[$class].staticProperties[name]){metadata.allowed=constructor[$class].staticProperties[name].allowed}}else{if(constructor[$class].properties[name]){metadata.allowed=constructor[$class].properties[name].allowed}}}if(forcePublic){forcePublicMetadata(metadata)}if(!metadata){throw new Error("Value of "+(isConst?"constant ":(isStatic?"static ":""))+' property "'+name+'" defined in class "'+constructor.prototype.$name+"\" can't be undefined (use null instead).")}if(isConst&&!metadata.isImmutable){throw new Error('Value for constant "'+name+'" defined in class "'+constructor.prototype.$name+'" must be a primitive type (immutable).')}if(metadata.isPrivate&&isFinal){throw new Error((isStatic?"Static property":"Property")+' "'+name+'" cannot be classified as final in class "'+constructor.prototype.$name+'".')}target=isStatic?constructor[$class].staticMethods:constructor[$class].methods;if(isObject(target[name])){throw new Error((isConst?"Constant property":(isStatic?"Static property":"Property"))+' "'+name+'" is overwriting a '+(isStatic?"static ":"")+'method with the same name in class "'+constructor.prototype.$name+'".')}target=isStatic?constructor[$class].staticProperties:constructor[$class].properties;if(isObject(target[name])){if(target[name].forcedPublic){forcePublicMetadata(metadata)}else{if(target[name].isPrivate){throw new Error("Cannot override private "+(isConst?"constant ":(isStatic?"static ":""))+' property "'+name+' in class "'+constructor.prototype.$name+'".')}}if(target[name].isConst){throw new Error('Cannot override constant property "'+name+'" in class "'+constructor.prototype.$name+'".')}if(target[name].isFinal){throw new Error('Cannot override final property "'+name+'" in class "'+constructor.prototype.$name+'".')}}target[name]=metadata;metadata.value=value;if(!isStatic){constructor[$class].ownMembers[name]=true}if(metadata.isPublic||!hasDefineProperty){target=isStatic?constructor:constructor.prototype;target[name]=value}if(isFinal){metadata.isFinal=isFinal}else{if(isConst){metadata.isConst=isConst}}if(metadata.isProtected){if(metadata.allowed){insert(metadata.allowed,constructor[$class].id)}else{metadata.allowed=[constructor[$class].id]}}else{if(metadata.isPrivate){metadata.allowed=constructor[$class].id}}}function forcePublicMetadata(metadata){delete metadata.isProtected;delete metadata.isPrivate;metadata.isPublic=metadata.forcedPublic=true}function borrowFromVanilla(params,constructor){var key,value,opts={forcePublic:true};for(key in params){if(/^(_){0,2}initialize$/.test(key)){continue}value=params[key];if(!hasOwn(constructor.prototype,key)){if(isFunction(value)&&!value[$class]&&!value[$interface]){addMethod(key,value,constructor,opts)}else{addProperty(key,value,constructor,opts)}}}constructor[$class].forceUnlocked=true}function parseBorrows(params,constructor){if(hasOwn(params,"$borrows")){var current,mixins=toArray(params.$borrows),i=mixins.length,key,opts={};if(!i&&!isArray(params.$borrows)){throw new Error('$borrows of class "'+constructor.prototype.$name+'" must be a class/object or an array of classes/objects.')}if(i!==unique(mixins).length&&compact(mixins).length===i){throw new Error('There are duplicate entries defined in $borrows of class "'+constructor.prototype.$name+'".')}for(i-=1;i>=0;i-=1){current=mixins[i];if(isObject(current)){if(current.$static){throw new Error("Entry at index "+i+' in $borrows of class "'+constructor.prototype.$name+'" is not a valid class/object.')}borrowFromVanilla(current,constructor);continue}if(isFunction(current)&&!current[$interface]){if(!current[$class]){borrowFromVanilla(current.prototype,constructor);continue}}else{throw new Error("Entry at index "+i+' in $borrows of class "'+constructor.prototype.$name+'" is not a valid class/object.')}current=current.prototype;if(current.$static[$abstract]&&current.$static[$abstract].unimplemented){throw new Error("Entry at index "+i+' in $borrows of class "'+constructor.prototype.$name+'" is an abstract class with abstract members, which are not allowed.')}if(current.$static.$parent){throw new Error("Entry at index "+i+' in $borrows of class "'+constructor.prototype.$name+'" is an inherited class (only root classes are supported).')}delete opts.isStatic;for(key in current.$static[$class].methods){if(!hasOwn(constructor.prototype,key)){opts.metadata=mixIn({},current.$static[$class].methods[key]);delete opts.metadata.allowed;addMethod(key,opts.metadata.implementation||current[key],constructor,opts)}}for(key in current.$static[$class].properties){if(!hasOwn(constructor.prototype,key)){opts.metadata=mixIn({},current.$static[$class].properties[key]);delete opts.metadata.allowed;addProperty(key,opts.metadata.value||current[key],constructor,opts)}}opts.isStatic=true;for(key in current.$static[$class].staticMethods){opts.metadata=mixIn({},current.$static[$class].staticMethods[key]);delete opts.metadata.allowed;addMethod(key,opts.metadata.implementation||current.$static[key],constructor,opts)}for(key in current.$static[$class].staticProperties){opts.metadata=mixIn({},current.$static[$class].staticProperties[key]);delete opts.metadata.allowed;addProperty(key,opts.metadata.value||current.$static[key],constructor,opts)}if(current.$static[$class].isVanilla){constructor[$class].forceUnlocked=true}combine(constructor[$class].binds,current.$static[$class].binds)}delete params.$borrows}}function handleInterfaces(interfs,target){var interfaces=toArray(interfs),interf,x=interfaces.length,k,opts={isConst:true};if(!x&&!isArray(interfs)){throw new Error('$implements of class "'+target.prototype.$name+'" must be an interface or an array of interfaces.')}if(x!==unique(interfaces).length&&compact(interfaces).length===x){throw new Error('There are duplicate entries in $implements of class "'+target.prototype.$name+'".')}for(x-=1;x>=0;x-=1){interf=interfaces[x];if(!isFunction(interf)||!interf[$interface]){throw new Error("Entry at index "+x+' in $implements of class "'+target.prototype.$name+'" is not a valid interface.')}if(!contains(target[$class].interfaces,interf)){for(k in interf[$interface].constants){addProperty(k,interf[k],target,opts)}target[$class].interfaces.push(interf)}if(!target[$abstract]){interfaces[x][$interface].check(target)}}}function parseMembers(params,constructor,isFinal){var opts={isFinal:!!isFinal},key,value,cache={},unallowed;if(hasOwn(params,"$statics")){if(!isObject(params.$statics)){throw new Error('$statics definition of class "'+params.$name+'" must be an object.')}checkKeywords(params.$statics,"statics");unallowed=testKeywords(params.$statics);if(unallowed){throw new Error("$statics "+(isFinal?"inside $finals ":"")+' of class "'+constructor.prototype.$name+'" contains an unallowed keyword: "'+unallowed+'".')}opts.isStatic=true;for(key in params.$statics){value=params.$statics[key];if(isFunction(value)&&!value[$class]&&!value[$interface]){addMethod(key,value,constructor,opts)}else{addProperty(key,value,constructor,opts)}}delete opts.isStatic;delete params.$statics}if(hasOwn(params,"$implements")){cache.$implements=params.$implements;delete params.$implements}if(hasOwn(params,"$abstracts")){cache.$abstracts=params.$abstracts;delete params.$abstracts}for(key in params){value=params[key];if(isFunction(value)&&!value[$class]&&!value[$interface]){addMethod(key,value,constructor,opts)}else{addProperty(key,value,constructor,opts)}}mixIn(params,cache)}function parseClass(params,constructor){var opts={},key,value,saved={},unallowed,ambiguous;if(hasOwn(params,"$constants")){if(!isObject(params.$constants)){throw new Error('$constants of class "'+constructor.prototype.$name+'" must be an object.')}checkKeywords(params.$constants,"statics");unallowed=testKeywords(params.$constants);if(unallowed){throw new Error('$constants of class "'+constructor.prototype.$name+'" contains an unallowed keyword: "'+unallowed+'".')}if(isObject(params.$statics)){ambiguous=intersection(keys(params.$constants),keys(params.$statics));if(ambiguous.length){throw new Error('There are members defined in class "'+constructor.prototype.$name+'" with the same name but with different modifiers: "'+ambiguous.join('", ')+'".')}}saved.$constants=params.$constants;delete params.$constants}if(hasOwn(params,"$finals")){if(!isObject(params.$finals)){throw new Error('$finals of class "'+constructor.prototype.$name+'" must be an object.')}checkKeywords(params.$finals);unallowed=testKeywords(params.$finals,["$statics"]);if(unallowed){throw new Error('$finals of class "'+constructor.prototype.$name+'" contains an unallowed keyword: "'+unallowed+'".')}if(isObject(params.$finals.$statics)){if(isObject(params.$statics)){ambiguous=intersection(keys(params.$finals.$statics),keys(params.$statics));if(ambiguous.length){throw new Error('There are members defined in class "'+constructor.prototype.$name+'" with the same name but with different modifiers: "'+ambiguous.join('", ')+'".')}}if(saved.$constants){ambiguous=intersection(keys(params.$finals.$statics),keys(saved.$constants));if(ambiguous.length){throw new Error('There are members defined in class "'+constructor.prototype.$name+'" with the same name but with different modifiers: "'+ambiguous.join('", ')+'".')}}}ambiguous=intersection(keys(params),keys(params.$finals));if(ambiguous.length){remove(ambiguous,"$statics");if(ambiguous.length){throw new Error('There are members defined in class "'+constructor.prototype.$name+'" with the same name but with different modifiers: "'+ambiguous.join('", ')+'".')}}saved.$finals=params.$finals;delete params.$finals}if(hasOwn(params,"$locked")){if(!isBoolean(params.$locked)){throw new Error('$locked of class "'+constructor.prototype.name+'" must be a boolean.')}saved.$locked=params.$locked;delete params.$locked}parseMembers(params,constructor);if(saved.$constants){opts.isConst=true;for(key in saved.$constants){value=saved.$constants[key];addProperty(key,value,constructor,opts)}delete opts.isConst}if(saved.$finals){parseMembers(saved.$finals,constructor,true)}if(hasOwn(saved,"$locked")){if(constructor[$class].forceUnlocked&&saved.$locked){throw new Error('Class "'+constructor.prototype.$name+'" cannot be locked because it borrows or extends from a vanilla class.')}if(constructor[$class].locked===false&&saved.$locked){throw new Error('Class "'+constructor.prototype.$name+'" inherits from an unlocked class, therefore its subclasses cannot be locked.')}constructor[$class].locked=!!saved.$locked;delete constructor.prototype.$locked}else{if(!hasOwn(constructor[$class],"locked")){constructor[$class].locked=!!options.locked}}}function applyBinds(fns,instance){var i,current;for(i=fns.length-1;i>=0;i-=1){current=instance[fns[i]];instance[fns[i]]=bind(current,instance);instance[fns[i]][$name]=current.$name}}function protectMethod(name,meta,instance){instance[cacheKeyword].methods[name]=meta.implementation;if(meta.isPrivate){Object.defineProperty(instance,name,{get:function get(){var method=instance[cacheKeyword].methods[name],isConstructor=name==="initialize",currCaller;currCaller=caller;if(instance.$initializing||(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&meta.allowed===currCaller.constructorId)){return method}if(!isConstructor){throw new Error('Cannot access private method "'+name+'" of class "'+instance.$name+'".')}else{throw new Error('Constructor of class "'+instance.$name+'" is private.')}},set:function set(newVal){if(instance.$initializing||!instance.$static[$class].locked||instance.$static[$class].forceUnlocked){instance[cacheKeyword].methods[name]=newVal;instance[redefinedCacheKeyword].methods[name]=true}else{throw new Error('Cannot set private method "'+name+'" of class "'+instance.$name+'".')}},configurable:false,enumerable:true})}else{if(meta.isProtected){Object.defineProperty(instance,name,{get:function get(){var method=instance[cacheKeyword].methods[name],isConstructor=name==="initialize",currCaller;currCaller=caller;if(instance.$initializing||(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&(contains(meta.allowed,currCaller.constructorId)||instance instanceof currCaller.constructor))){return method}if(!isConstructor){throw new Error('Cannot access protected method "'+name+'" of class "'+instance.$name+'".')}else{throw new Error('Constructor of class "'+instance.$name+'" is protected.')}},set:function set(newVal){if(instance.$initializing||!instance.$static[$class].locked||instance.$static[$class].forceUnlocked){instance[cacheKeyword].methods[name]=newVal;instance[redefinedCacheKeyword].methods[name]=true}else{throw new Error('Cannot set protected method "'+name+'" of class "'+instance.$name+'".')}},configurable:false,enumerable:true})}else{Object.defineProperty(instance,name,{get:function get(){return instance[cacheKeyword].methods[name]},set:function set(newVal){if(instance.$initializing||!instance.$static[$class].locked||instance.$static[$class].forceUnlocked){instance[cacheKeyword].methods[name]=newVal;instance[redefinedCacheKeyword].methods[name]=true}else{throw new Error('Cannot set public method "'+name+'" of class "'+instance.$name+'".')}},configurable:false,enumerable:true})}}}function protectStaticMethod(name,meta,constructor){constructor[cacheKeyword].methods[name]=meta.implementation;if(meta.isPrivate){Object.defineProperty(constructor,name,{get:function get(){var method=constructor[cacheKeyword].methods[name],currCaller;currCaller=caller;if(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&meta.allowed===currCaller.constructorId){return method}throw new Error('Cannot access private static method "'+name+'" of class "'+constructor.prototype.$name+'".')},set:function set(newVal){if(!constructor[$class].locked||constructor[$class].forceUnlocked){constructor[cacheKeyword].methods[name]=newVal}else{throw new Error('Cannot set private static method "'+name+'" of class "'+constructor.prototype.$name+'".')}},configurable:false,enumerable:true})}else{if(meta.isProtected){Object.defineProperty(constructor,name,{get:function get(){var method=constructor[cacheKeyword].methods[name],currCaller;currCaller=caller;if(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&(contains(meta.allowed,currCaller.constructorId)||constructor.prototype instanceof currCaller.constructor)){return method}throw new Error('Cannot access protected static method "'+name+'" of class "'+constructor.prototype.$name+'".')},set:function set(newVal){if(!constructor[$class].locked||constructor[$class].forceUnlocked){constructor[cacheKeyword].methods[name]=newVal}else{throw new Error('Cannot set protected static method "'+name+'" of class "'+constructor.prototype.$name+'".')}},configurable:false,enumerable:true})}else{Object.defineProperty(constructor,name,{get:function get(){return constructor[cacheKeyword].methods[name]},set:function set(newVal){if(!constructor[$class].locked||constructor[$class].forceUnlocked){constructor[cacheKeyword].methods[name]=newVal}else{throw new Error('Cannot set public static method "'+name+'" of class "'+constructor.prototype.$name+'".')}},configurable:false,enumerable:true})}}}function protectProperty(name,meta,instance){if(meta.isPrivate){if(!meta.isImmutable){instance[cacheKeyword].properties[name]=deepClone(meta.value);instance[redefinedCacheKeyword].properties[name]=true}else{instance[cacheKeyword].properties[name]=meta.value}Object.defineProperty(instance,name,{get:function get(){var currCaller=caller;if(instance.$initializing||(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&meta.allowed===currCaller.constructorId)){return instance[cacheKeyword].properties[name]}throw new Error('Cannot access private property "'+name+'" of class "'+instance.$name+'".')},set:function set(newVal){var currCaller=caller;if(instance.$initializing||(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&meta.allowed===currCaller.constructorId)){instance[cacheKeyword].properties[name]=newVal;instance[redefinedCacheKeyword].properties[name]=true}else{throw new Error('Cannot set private property "'+name+'" of class "'+instance.$name+'".')}},configurable:false,enumerable:true})}else{if(meta.isProtected){if(!meta.isImmutable){instance[cacheKeyword].properties[name]=deepClone(meta.value);instance[redefinedCacheKeyword].properties[name]=true}else{instance[cacheKeyword].properties[name]=meta.value}Object.defineProperty(instance,name,{get:function get(){var currCaller=caller;if(instance.$initializing||(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&(contains(meta.allowed,currCaller.constructorId)||instance instanceof currCaller.constructor))){return instance[cacheKeyword].properties[name]}throw new Error('Cannot access protected property "'+name+'" of class "'+instance.$name+'".')},set:function set(newVal){var currCaller=caller;if(instance.$initializing||(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&(contains(meta.allowed,currCaller.constructorId)||instance instanceof currCaller.constructor))){instance[cacheKeyword].properties[name]=newVal;instance[redefinedCacheKeyword].properties[name]=true}else{throw new Error('Cannot set protected property "'+name+'" of class "'+instance.$name+'".')}},configurable:false,enumerable:true})}else{if(!meta.isImmutable){instance[name]=deepClone(instance[name]);instance[redefinedCacheKeyword].properties[name]=true}else{instance[name]=meta.value}}}}function protectStaticProperty(name,meta,constructor){constructor[cacheKeyword].properties[name]=meta.value;if(meta.isPrivate){Object.defineProperty(constructor,name,{get:function get(){var currCaller=caller;if(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&meta.allowed===currCaller.constructorId){return constructor[cacheKeyword].properties[name]}throw new Error('Cannot access private static property "'+name+'" of class "'+constructor.prototype.$name+'".')},set:meta.isConst?function(){throw new Error('Cannot change value of constant property "'+name+'" of class "'+constructor.prototype.$name+'".')}:function set(newVal){var currCaller=caller;if(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&meta.allowed===currCaller.constructorId){constructor[cacheKeyword].properties[name]=newVal}else{throw new Error('Cannot set private property "'+name+'" of class "'+constructor.prototype.$name+'".')}},configurable:false,enumerable:true})}else{if(meta.isProtected){Object.defineProperty(constructor,name,{get:function get(){var currCaller=caller;if(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&(contains(meta.allowed,currCaller.constructorId)||constructor.prototype instanceof currCaller.constructor)){return constructor[cacheKeyword].properties[name]}throw new Error('Cannot access protected static property "'+name+'" of class "'+constructor.prototype.$name+'".')},set:meta.isConst?function(){throw new Error('Cannot change value of constant property "'+name+'" of class "'+constructor.prototype.$name+'".')}:function set(newVal){var currCaller=caller;if(currCaller&&(currCaller.method[$name]||currCaller.method[$anonymous])&&(contains(meta.allowed,currCaller.constructorId)||constructor.prototype instanceof currCaller.constructor)){constructor[cacheKeyword].properties[name]=newVal}else{throw new Error('Cannot set protected static property "'+name+'" of class "'+constructor.prototype.$name+'".')}},configurable:false,enumerable:true})}else{if(meta.isConst){Object.defineProperty(constructor,name,{get:function(){return constructor[cacheKeyword].properties[name]},set:function(){throw new Error('Cannot change value of constant property "'+name+'" of class "'+constructor.prototype.$name+'".')},configurable:false,enumerable:true})}}}}function protectInstance(instance){var key;obfuscateProperty(instance,cacheKeyword,{properties:{},methods:{}});obfuscateProperty(instance,redefinedCacheKeyword,{properties:{},methods:{}});for(key in instance.$static[$class].methods){protectMethod(key,instance.$static[$class].methods[key],instance)}for(key in instance.$static[$class].properties){protectProperty(key,instance.$static[$class].properties[key],instance)}}function protectConstructor(constructor){var key,target,meta,prototype=constructor.prototype;obfuscateProperty(constructor,cacheKeyword,{properties:{},methods:{}});for(key in constructor[$class].staticMethods){protectStaticMethod(key,constructor[$class].staticMethods[key],constructor)}for(key in constructor[$class].staticProperties){protectStaticProperty(key,constructor[$class].staticProperties[key],constructor)}if(isFunction(Object.seal)&&constructor[$class].locked&&!constructor[$class].forceUnlocked){Object.seal(constructor);Object.seal(prototype)}}function createConstructor(constructor,isAbstract){var Instance=constructor||function Instance(){var x,tmp;if(!(this instanceof Instance)){throw new Error("Constructor called as a function, use the new keyword instead.")}if(isAbstract){throw new Error("An abstract class cannot be instantiated.")}obfuscateProperty(this,"$initializing",true,true,true);obfuscateProperty(this,"$super",null,true);obfuscateProperty(this,"$self",null,true);tmp=this.$static[$class];if(hasDefineProperty){protectInstance(this)}else{for(x in tmp.properties){if(!tmp.properties[x].isImmutable){this[x]=deepClone(this[x])}}}if(tmp.binds.length){applyBinds(tmp.binds,this,this)}delete this.$initializing;if(!tmp.forceUnlocked&&tmp.locked&&isFunction(Object.seal)){Object.seal(this)}this.initialize.apply(this,arguments)};if(!Instance[$class]){obfuscateProperty(Instance,$class,{methods:{},properties:{},staticMethods:{},staticProperties:{},ownMembers:{},interfaces:[],binds:[]});if(hasDefineProperty){Instance[$class].simpleConstructor=function(){};obfuscateProperty(Instance[$class].simpleConstructor,"$constructor",Instance)}}return Instance}function doMember(func){func=func||this;if(func[$name]){return func}if(!caller){throw new Error("Attempting to mark a function as a member outside an instance/class.")}if(func[$anonymous]){throw new Error("Function is already marked as an member.")}func[$anonymous]=true;func=wrapMethod(null,func,caller.constructor);func[$anonymous]=true;return func}function defaultSuper(){throw new Error("Trying to call $super when there is no parent function.")}function doBind(func){var args=toArray(arguments),bound,isAnonymous;if(this&&!func[$wrapped]&&this.$static&&this.$static[$class]){func[$anonymous]=true;func=wrapMethod(null,func,this.$self||this.$static);args[0]=func;isAnonymous=true}args.splice(1,0,this);bound=bind.apply(func,args);if(isAnonymous){bound[$anonymous]=func[$anonymous]=true}return bound}function doBindStatic(func){var args=toArray(arguments),bound,isAnonymous;if(this&&!func[$wrapped]&&this.$static&&this.$static[$class]){func[$anonymous]=true;func=wrapMethod(null,func,this.$self||this.$static,true);args[0]=func;isAnonymous=true}args.splice(1,0,this);bound=bind.apply(func,args);if(isAnonymous){bound[$anonymous]=func[$anonymous]=true}return bound}function inheritParent(constructor,parent){var x,binds=parent[$class].binds,key,value,classId=constructor[$class].id;for(x=binds.length-1;x>=0;x-=1){if(binds[x].substr(0,2)!=="__"){constructor[$class].binds.push(binds[x])}}for(key in parent[$class].methods){value=parent[$class].methods[key];constructor[$class].methods[key]=value;if(value.isProtected){value.allowed.push(classId)}}for(key in parent[$class].properties){value=parent[$class].properties[key];constructor[$class].properties[key]=value;if(value.isProtected){value.allowed.push(classId)}}for(key in parent[$class].staticMethods){value=parent[$class].staticMethods[key];if(!value.isPrivate){constructor[$class].staticMethods[key]=value;constructor[key]=value.implementation;if(value.isProtected){value.allowed.push(classId)}}}for(key in parent[$class].staticProperties){value=parent[$class].staticProperties[key];if(!value.isPrivate){constructor[$class].staticProperties[key]=value;constructor[key]=value.value;if(value.isProtected){value.allowed.push(classId)}}}if(hasDefineProperty){inheritPrototype(constructor[$class].simpleConstructor,parent[$class].simpleConstructor)}if(hasOwn(parent[$class],"locked")){constructor[$class].locked=parent[$class].locked}if(hasOwn(parent[$class],"forceUnlocked")){constructor[$class].forceUnlocked=parent[$class].forceUnlocked}obfuscateProperty(constructor,"$parent",parent);constructor[$class].interfaces=[].concat(parent[$class].interfaces)}function extend(params,$arg){return Class.declare(this,params,$arg)}toStringInstance=function(){return"[instance #"+this.$name+"]"};toStringConstructor=function(){return"[constructor #"+this.prototype.$name+"]"};createClass=function(params,constructor,opts){opts=opts||{};var dejavu,parent,tmp,key,x,found;if(hasOwn(params,"$name")){if(!isString(params.$name)){throw new Error("Class name must be a string.")}else{if(/\s+/.test(params.$name)){throw new Error("Class name cannot have spaces.")}}}else{params.$name="Unnamed"}if(hasOwn(params,"$abstracts")&&!opts.isAbstract){throw new Error('Class "'+params.$name+'" has abstract methods, therefore it must be defined as abstract.')}if(!opts.isVanilla){tmp=["__","_",""];found=false;for(x=tmp.length-1;x>=0;x-=1){key=tmp[x]+"initialize";if(hasOwn(params,key)){if(!isFunction(params[key])){throw new Error('The "'+key+'" member of class "'+params.$name+'" must be a function.')}if(found){throw new Error('Several constructors with different visibility where found in class "'+params.$name+'".')}found=true;params[key].$prefix=tmp[x]}}}checkKeywords(params,"normal");if(hasOwn(params,"$extends")){parent=params.$extends;delete params.$extends;if(isFunction(parent)&&!parent[$interface]){if(!parent[$class]){parent=createClass(parent.prototype,parent,{isVanilla:true})}if(parent[$class].finalClass){throw new Error('Class "'+params.$name+'" cannot inherit from final class "'+parent.prototype.$name+'".')}}else{throw new Error('Specified parent class in $extends of "'+params.$name+'" is not a valid class.')}dejavu=createConstructor(constructor,opts.isAbstract);dejavu[$class].id=nextId+=1;if(opts.isVanilla){params.initialize=function(){dejavu.apply(this,arguments)};dejavu[$class].forceUnlocked=true;dejavu[$class].isVanilla=true}else{if(!params.initialize&&!params._initialize&&!params.__initialize){params.initialize=function(){parent.prototype.initialize.apply(this,arguments)};params.initialize.$inherited=true}else{params.initialize=params.initialize||params._initialize||params.__initialize}}inheritPrototype(dejavu,parent);inheritParent(dejavu,parent)}else{dejavu=createConstructor(constructor,opts.isAbstract);dejavu[$class].id=nextId+=1;if(opts.isVanilla){params.initialize=function(){dejavu.apply(this,arguments)};dejavu[$class].forceUnlocked=true;dejavu[$class].isVanilla=true}else{params.initialize=params.initialize||params._initialize||params.__initialize||function(){}}}if(!opts.isVanilla){delete params._initialize;delete params.__initialize}if(opts.isAbstract){obfuscateProperty(dejavu,$abstract,true,true)}dejavu.prototype.$name=params.$name;delete params.$name;parseBorrows(params,dejavu);parseClass(params,dejavu);obfuscateProperty(dejavu.prototype,"$static",dejavu);obfuscateProperty(dejavu,"$static",dejavu);obfuscateProperty(dejavu,"$self",null,true);obfuscateProperty(dejavu,"$super",null,true);obfuscateProperty(dejavu,"$member",doMember);obfuscateProperty(dejavu,"$bind",doBindStatic);if(!dejavu.$parent){obfuscateProperty(dejavu.prototype,"$bind",doBind);obfuscateProperty(dejavu.prototype,"$member",doMember)}if(params.toString===Object.prototype.toString){obfuscateProperty(dejavu.prototype,"toString",toStringInstance,true)}if(dejavu.toString===Function.prototype.toString){obfuscateProperty(dejavu,"toString",toStringConstructor,true)}if(parent&&parent[$abstract]&&!opts.isAbstract){parent[$abstract].check(dejavu)}if(hasOwn(params,"$implements")){handleInterfaces(params.$implements,dejavu);delete dejavu.prototype.$implements}if(hasOwn(params,"$abstracts")){delete params.$abstracts}dejavu.extend=extend;if(hasDefineProperty){protectConstructor(dejavu)}return dejavu};Class.declare=function(arg1,arg2,$arg3){var params,callable=isFunction(this)?this:createClass,tmp,constructor;if(arg1&&arg2&&arg2!==true){if(!isFunction(arg1)||!arg1[$class]){throw new Error("Expected first argument to be a class.")}if((tmp=isFunction(arg2))||$arg3){constructor=createConstructor();params=tmp?arg2(arg1.prototype,arg1,constructor):arg2}else{params=arg2}if(params.$extends){throw new Error("Object cannot contain an $extends property.")}params.$extends=arg1}else{if((tmp=isFunction(arg1))||arg2){constructor=createConstructor();params=tmp?arg1(constructor):arg1}else{params=arg1}}if(!isObject(params)){throw new Error("Expected class definition to be an object with the class members.")}return callable(params,constructor)};obfuscateProperty(Class,"$create",createClass);if(!Function.prototype.$bound||!Function.prototype.$bound.dejavu){try{obfuscateProperty(Function.prototype,"$bound",function(){this[$bound]=true;return this});Function.prototype.$bound.dejavu=true}catch(e){printWarning("Could not set Function.prototype.$bound.")}}if(!Function.prototype.$bind||!Function.prototype.$bind.dejavu){try{obfuscateProperty(Function.prototype,"$bind",function(context){var args=toArray(arguments);args.splice(0,1,this);if(isFunction(context)){return doBindStatic.apply(context,args)}return doBind.apply(context,args)});Function.prototype.$bind.dejavu=true}catch(e){printWarning("Could not set Function.prototype.$bind.")}}if(!Function.prototype.$member||!Function.prototype.$member.dejavu){try{obfuscateProperty(Function.prototype,"$member",function(){return doMember(this)});Function.prototype.$member.dejavu=true}catch(e){printWarning("Could not set Function.prototype.$member.")}}return Class});define("lib/isFunctionEmpty",[],function(){function isFunctionEmpty(func){return(/^function\s*\([^\(]*\)\s*\{\s*(["']use strict["'];)?\s*\}$/m).test(func.toString())}return isFunctionEmpty});define("AbstractClass",["mout/lang/isObject","mout/lang/isFunction","mout/lang/isString","mout/lang/toArray","mout/function/bind","./lib/functionMeta","./lib/isFunctionEmpty","./lib/isFunctionCompatible","./lib/checkKeywords","./lib/testKeywords","./lib/checkObjectPrototype","./lib/hasDefineProperty","./lib/randomAccessor","./lib/mixIn","mout/object/hasOwn","mout/array/insert","./Class"],function AbstractClassWrapper(isObject,isFunction,isString,toArray,bind,functionMeta,isFunctionEmpty,isFunctionCompatible,checkKeywords,testKeywords,checkObjectPrototype,hasDefineProperty,randomAccessor,mixIn,hasOwn,insert,Class){var random=randomAccessor("AbstractClassWrapper"),$class="$class_"+random,$interface="$interface_"+random,$abstract="$abstract_"+random,$bound="$bound_"+random,AbstractClass={};checkObjectPrototype();function addMethod(name,method,constructor,opts){var metadata,isStatic=opts&&opts.isStatic,target;if(name.substr(0,2)==="__"){throw new Error('Abstract class "'+constructor.prototype.$name+'" contains an unallowed abstract '+(isStatic?"static ":"")+'private method: "'+name+'".')}if(!isFunctionEmpty(method)){throw new Error((isStatic?"Static method":"Method")+' "'+name+'" must be anonymous and contain no implementation in abstract class "'+constructor.prototype.$name+'".')}target=isStatic?constructor:constructor.prototype;metadata=functionMeta(method,name);if(metadata===null){throw new Error((isStatic?"Static method":"Method")+' "'+name+'" contains optional arguments before mandatory ones in abstract class "'+constructor.prototype.$name+'".')}target=isStatic?constructor[$class].staticProperties:constructor[$class].properties;if(isObject(target[name])){throw new Error('Abstract method "'+name+'" defined in abstract class "'+constructor.prototype.$name+'" conflicts with an already defined property.')}target=isStatic?constructor[$class].staticMethods:constructor[$class].methods;if(isObject(target[name])){throw new Error('Abstract method "'+name+'" defined in abstract class "'+constructor.prototype.$name+'" seems to be already implemented and cannot be declared as abstract anymore.')}target=isStatic?constructor[$abstract].staticMethods:constructor[$abstract].methods;if(isObject(target[name])){if(!isFunctionCompatible(metadata,target[name])){throw new Error((isStatic?"Static method":"Method")+' "'+name+"("+metadata.signature+')" defined in abstract class "'+constructor.prototype.$name+'" overrides its ancestor but it is not compatible with its signature: "'+name+"("+target[name].signature+')".')}}if(!isStatic&&method[$bound]){insert(constructor[$class].binds,name)}metadata.checkCompatibility=true;target[name]=metadata}function checkClass(target){var key,value;for(key in this[$abstract].methods){value=this[$abstract].methods[key];if(!target[$class].methods[key]){throw new Error('Class "'+target.prototype.$name+'" does not implement abstract class "'+this.prototype.$name+'" correctly, method "'+key+'" was not found.')}if(!isFunctionCompatible(target[$class].methods[key],value)){throw new Error('Method "'+key+"("+target[$class].methods[key].signature+')" defined in class "'+target.prototype.$name+'" is not compatible with the one found in abstract class "'+this.prototype.$name+'": "'+key+"("+value.signature+')".')}}for(key in this[$abstract].staticMethods){value=this[$abstract].staticMethods[key];if(!target[$class].staticMethods[key]){throw new Error('Class "'+target.prototype.$name+'" does not implement abstract class "'+this.prototype.$name+'" correctly, static method "'+key+'" was not found.')}if(!isFunctionCompatible(target[$class].staticMethods[key],value)){throw new Error('Static method "'+key+"("+target[$class].staticMethods[key].signature+')" defined in class "'+target.prototype.$name+'" is not compatible with the one found in abstract class "'+this.prototype.$name+'": "'+key+"("+value.signature+')".')}}}function parseAbstracts(abstracts,constructor){var optsStatic={isStatic:true},key,value,unallowed;if(!isObject(abstracts)){throw new Error('$abstracts defined in abstract class "'+constructor.prototype.$name+'" must be an object.')}checkKeywords(abstracts);unallowed=testKeywords(abstracts,["$statics"]);if(unallowed){throw new Error('$statics inside $abstracts of abstract class "'+constructor.prototype.$name+'" contains an unallowed keyword: "'+unallowed+'".')}if(hasOwn(abstracts,"$statics")){if(!isObject(abstracts.$statics)){throw new Error('$statics definition in $abstracts of abstract class "'+constructor.prototype.$name+'" must be an object.')}checkKeywords(abstracts.$statics,"statics");unallowed=testKeywords(abstracts.$statics);if(unallowed){throw new Error('$statics inside $abstracts of abstract class "'+constructor.prototype.$name+'" contains an unallowed keyword: "'+unallowed+'".')}for(key in abstracts.$statics){value=abstracts.$statics[key];if(!isFunction(value)||value[$interface]||value[$class]){throw new Error('Abstract member "'+key+'" found in abstract class "'+constructor.prototype.$name+'" is not a function.')}addMethod(key,value,constructor,optsStatic)}delete abstracts.$statics}for(key in abstracts){value=abstracts[key];if(!isFunction(value)||value[$interface]||value[$class]){throw new Error('Abstract member "'+key+'" found in abstract class "'+constructor.prototype.$name+'" is not a function.')}addMethod(key,value,constructor)}}function parseInterfaces(interfaces,constructor){var interfs=toArray(interfaces),x=interfs.length,interf,key,value;for(x-=1;x>=0;x-=1){interf=interfs[x];for(key in interf[$interface].methods){value=interf[$interface].methods[key];if(constructor[$abstract].methods[key]){if(!isFunctionCompatible(constructor[$abstract].methods[key],value)){throw new Error('Method "'+key+"( "+value.signature+')" described in interface "'+interf.prototype.$name+'" is not compatible with the one already defined in "'+constructor.prototype.$name+'": "'+key+"("+constructor[$abstract].methods[key].signature+')".')}}else{constructor[$abstract].methods[key]=interf[$interface].methods[key]}}for(key in interf[$interface].staticMethods){value=interf[$interface].staticMethods[key];if(constructor[$abstract].staticMethods[key]){if(!isFunctionCompatible(constructor[$abstract].staticMethods[key],value)){throw new Error('Static method "'+key+"( "+value.signature+')" described in interface "'+interf.prototype.$name+'" is not compatible with the one already defined in "'+constructor.prototype.$name+'": "'+key+"("+constructor[$abstract].staticMethods[key].signature+')".')}}else{constructor[$abstract].staticMethods[key]=value}}}}function createAbstractClass(params,constructor){if(!isObject(params)){throw new Error("Expected abstract class definition to be an object with the abstract class members.")}if(hasOwn(params,"$name")){if(!isString(params.$name)){throw new Error("Abstract class name must be a string.")}else{if(/\s+/.test(params.$name)){throw new Error("Abstract class name cannot have spaces.")}}}else{params.$name="Unnamed"}var def,abstractObj={methods:{},staticMethods:{},unimplemented:0},saved={},key;if(isFunction(params.$extends)){if(params.$extends[$abstract]){mixIn(abstractObj.methods,params.$extends[$abstract].methods);mixIn(abstractObj.staticMethods,params.$extends[$abstract].staticMethods)}}if(hasOwn(params,"$abstracts")){saved.$abstracts=params.$abstracts}if(hasOwn(params,"$implements")){saved.$interfaces=params.$implements}def=Class.$create(params,constructor,{isAbstract:true});abstractObj.check=bind(checkClass,def);if(hasDefineProperty){Object.defineProperty(def,$abstract,{value:abstractObj,writable:false})}else{def[$abstract]=abstractObj}if(hasOwn(saved,"$interfaces")){parseInterfaces(saved.$interfaces,def)}if(hasOwn(saved,"$abstracts")){parseAbstracts(saved.$abstracts,def)}for(key in def[$abstract].methods){if(!def[$class].methods[key]){abstractObj.unimplemented+=1}}for(key in def[$abstract].staticMethods){if(!def[$class].staticMethods[key]){abstractObj.unimplemented+=1}}return def}AbstractClass.declare=function(arg1,arg2,$arg3){return Class.declare.call(createAbstractClass,arg1,arg2,$arg3)};return AbstractClass});define("Interface",["mout/lang/isObject","mout/lang/isArray","mout/lang/isString","mout/function/bind","mout/array/intersection","mout/array/unique","mout/array/compact","mout/object/keys","./lib/checkKeywords","./lib/testKeywords","./lib/functionMeta","./lib/isFunctionEmpty","./lib/isFunctionCompatible","./lib/checkObjectPrototype","./lib/obfuscateProperty","./lib/randomAccessor","./lib/isImmutable","./lib/hasDefineProperty","./lib/mixIn","mout/lang/isFunction","mout/object/hasOwn","mout/lang/toArray"],function InterfaceWrapper(isObject,isArray,isString,bind,intersection,unique,compact,keys,checkKeywords,testKeywords,functionMeta,isFunctionEmpty,isFunctionCompatible,checkObjectPrototype,obfuscateProperty,randomAccessor,isImmutable,hasDefineProperty,mixIn,isFunction,hasOwn,toArray){var random=randomAccessor("InterfaceWrapper"),$class="$class_"+random,$interface="$interface_"+random,Interface={};checkObjectPrototype();function checkClass(target){var key,value;for(key in this[$interface].methods){value=this[$interface].methods[key];if(!target[$class].methods[key]){throw new Error('Class "'+target.prototype.$name+'" does not implement interface "'+this.prototype.$name+'" correctly, method "'+key+'" was not found.')}if(!isFunctionCompatible(target[$class].methods[key],value)){throw new Error('Method "'+key+"("+target[$class].methods[key].signature+')" defined in class "'+target.prototype.$name+'" is not compatible with the one found in interface "'+this.prototype.$name+'": "'+key+"("+value.signature+')".')}}for(key in this[$interface].staticMethods){value=this[$interface].staticMethods[key];if(!target[$class].staticMethods[key]){throw new Error('Class "'+target.prototype.$name+'" does not implement interface "'+this.prototype.$name+'" correctly, static method "'+key+'" was not found.')}if(!isFunctionCompatible(target[$class].staticMethods[key],value)){throw new Error('Static method "'+key+"("+target[$class].staticMethods[key].signature+')" defined in class "'+target.prototype.$name+'" is not compatible with the one found in interface "'+this.prototype.$name+'": "'+key+"("+value.signature+')".')}}}function addMethod(name,method,interf,opts){var metadata,isStatic=opts&&opts.isStatic,target;if(!isFunction(method)||method[$interface]||method[$class]){throw new Error('Member "'+name+'" found in interface "'+interf.prototype.$name+'" is not a function.')}if(name.charAt(0)==="_"){throw new Error('Interface "'+interf.prototype.$name+'" contains an unallowed non public method: "'+name+'".')}if(!isFunctionEmpty(method)){throw new Error((isStatic?"Static method":"Method")+' "'+name+'" must be anonymous and contain no implementation in interface "'+interf.prototype.$name+'".')}metadata=functionMeta(method,name);if(metadata===null){throw new Error((isStatic?"Static method":"Method")+' "'+name+'" contains optional arguments before mandatory ones in interface "'+interf.prototype.$name+'".')}target=isStatic?interf[$interface].staticMethods:interf[$interface].methods;if(isObject(target[name])){if(!isFunctionCompatible(metadata,target[name])){throw new Error((isStatic?"Static method":"Method")+' "'+name+"("+metadata.signature+')" defined in interface "'+interf.prototype.$name+'" overrides its ancestor but it is not compatible with its signature: "'+name+"("+target[name].signature+')".')}}target[name]=metadata}function assignConstant(name,value,interf){if(hasDefineProperty){Object.defineProperty(interf,name,{get:function(){return value},set:function(){throw new Error('Cannot change value of constant property "'+name+'" of interface "'+this.prototype.$name+'".')},configurable:false,enumerable:true})}else{interf[name]=value}}function addConstant(name,value,interf){var target;if(name.charAt(0)==="_"){throw new Error('Interface "'+interf.prototype.$name+'" contains an unallowed non public method: "'+name+'".')}if(!isImmutable(value)){throw new Error('Value for constant property "'+name+'" defined in interface "'+interf.prototype.$name+'" must be a primitive type.')}target=interf[$interface].constants;if(target[name]){throw new Error('Cannot override constant property "'+name+'" in interface "'+interf.prototype.$name+'".')}target[name]=true;assignConstant(name,value,interf)}function extend(params){if(params.$extends){throw new Error("Object passed cannot contain an $extends property.")}params.$extends=this;return Interface.declare(params)}function createInterface(params){if(!isObject(params)){throw new Error("Expected interface definition to be an object with the interface members.")}if(hasOwn(params,"$name")){if(!isString(params.$name)){throw new Error("Interface name must be a string.")}else{if(/\s+/.test(params.$name)){throw new Error("Interface name cannot have spaces.")}}}else{params.$name="Unnamed"}checkKeywords(params);var parents,current,k,i,value,duplicate,opts={},name,ambiguous,unallowed,interf=function(){throw new Error("Interfaces cannot be instantiated.")};obfuscateProperty(interf,$interface,{parents:[],methods:{},staticMethods:{},constants:{},check:bind(checkClass,interf)});interf.prototype.$name=params.$name;if(hasOwn(params,"$extends")){parents=toArray(params.$extends);k=parents.length;if(!k&&!isArray(params.$extends)){throw new Error('$extends of "'+params.$name+'" seems to point to an nonexistent interface.')}if(k!==unique(parents).length&&compact(parents).length===k){throw new Error('There are duplicate entries defined in $extends of "'+params.$name+'".')}for(k-=1;k>=0;k-=1){current=parents[k];if(!isFunction(current)||!current[$interface]){throw new Error("Specified interface in $extends at index "+k+' of "'+params.$name+'" is not a valid interface.')}duplicate=intersection(keys(interf[$interface].methods),keys(current[$interface].methods));i=duplicate.length;if(i){for(i-=1;i>=0;i-=1){if(!isFunctionCompatible(interf[$interface].methods[duplicate[i]],current[$interface].methods[duplicate[i]])&&!isFunctionCompatible(current[$interface].methods[duplicate[i]],interf[$interface].methods[duplicate[i]])){throw new Error('Interface "'+params.$name+'" is inheriting method "'+duplicate[i]+'" from different parents with incompatible signatures.')}}}mixIn(interf[$interface].methods,current[$interface].methods);duplicate=intersection(keys(interf[$interface].staticMethods),keys(current[$interface].staticMethods));i=duplicate.length;if(i){for(i-=1;i>=0;i-=1){if(!isFunctionCompatible(interf[$interface].staticMethods[duplicate[i]],current[$interface].staticMethods[duplicate[i]])&&!isFunctionCompatible(current[$interface].staticMethods[duplicate[i]],interf[$interface].staticMethods[duplicate[i]])){throw new Error('Interface "'+params.$name+'" is inheriting static method "'+duplicate[i]+'" from different parents with incompatible signatures.')}}}mixIn(interf[$interface].staticMethods,current[$interface].staticMethods);for(i in current[$interface].constants){if(interf[$interface].constants[i]){if(interf[i]!==current[i]){throw new Error('Interface "'+params.$name+'" is inheriting constant property "'+i+'" from different parents with different values.')}}else{interf[$interface].constants[i]=current[$interface].constants[i];assignConstant(i,current[i],interf)}}interf[$interface].parents.push(current)}delete params.$extends}if(hasOwn(params,"initialize")){throw new Error('Interface "'+params.$name+"\" can't define the initialize method.")}if(hasOwn(params,"$constants")){if(!isObject(params.$constants)){throw new Error('$constants definition of interface "'+params.$name+'" must be an object.')}checkKeywords(params.$constants,"statics");unallowed=testKeywords(params.$constants);if(unallowed){throw new Error('$constants of interface "'+interf.prototype.$name+'" contains an unallowed keyword: "'+unallowed+'".')}if(hasOwn(params,"$statics")){ambiguous=intersection(keys(params.$constants),keys(params.$statics));if(ambiguous.length){throw new Error('There are members defined in interface "'+params.$name+'" with the same name but with different modifiers: "'+ambiguous.join('", ')+'".')}}for(k in params.$constants){addConstant(k,params.$constants[k],interf)}delete params.$constants}if(hasOwn(params,"$statics")){if(!isObject(params.$statics)){throw new Error('$statics definition of interface "'+params.$name+'" must be an object.')}checkKeywords(params.$statics,"statics");unallowed=testKeywords(params.$statics);if(unallowed){throw new Error('$statics of interface "'+interf.prototype.$name+'" contains an unallowed keyword: "'+unallowed+'".')}opts.isStatic=true;for(k in params.$statics){value=params.$statics[k];if(!isFunction(value)||value[$interface]||value[$class]){throw new Error('Static member "'+k+'" found in interface "'+params.$name+'" is not a function.')}addMethod(k,value,interf,opts)}delete opts.isStatic;delete params.$statics}name=params.$name;delete params.$name;unallowed=testKeywords(params,["$extends","$statics","$constants"]);if(unallowed){throw new Error('$statics of interface "'+interf.prototype.$name+'" contains an unallowed keyword: "'+unallowed+'".')}for(k in params){addMethod(k,params[k],interf)}params.$name=name;interf.extend=extend;return interf}Interface.declare=createInterface;return Interface});define("FinalClass",["./Class","./lib/randomAccessor","./lib/checkObjectPrototype"],function FinalClassWrapper(Class,randomAccessor,checkObjectPrototype){checkObjectPrototype();var random=randomAccessor("FinalClassWrapper"),$class="$class_"+random,FinalClass={};function createFinalClass(params,constructor){var def=Class.$create(params,constructor);def[$class].finalClass=true;return def}FinalClass.declare=function(arg1,arg2,$arg3){return Class.declare.call(createFinalClass,arg1,arg2,$arg3)};return FinalClass});define("instanceOf",["mout/lang/isFunction","./lib/randomAccessor"],function instanceOfWrapper(isFunction,randomAccessor){var random=randomAccessor("instanceOfWrapper"),$class="$class_"+random,$interface="$interface_"+random;function interfaceDescendantOf(interf1,interf2){var x,parents=interf1[$interface].parents;for(x=parents.length-1;x>=0;x-=1){if(parents[x]===interf2){return true}if(interfaceDescendantOf(interf1,parents[x])){return true}}return false}function instanceOfInterface(instance,target){var x,interfaces=instance.$static[$class].interfaces;for(x=interfaces.length-1;x>=0;x-=1){if(interfaces[x]===target||interfaceDescendantOf(interfaces[x],target)){return true}}return false}function instanceOf(instance,target){if(!isFunction(target)){return false}if(instance instanceof target){return true}if(instance&&instance.$static&&instance.$static[$class]&&target&&target[$interface]){return instanceOfInterface(instance,target)}return false}return instanceOf});define("dejavu",["./Class","./AbstractClass","./Interface","./FinalClass","./instanceOf","./options"],function(Class,AbstractClass,Interface,FinalClass,instanceOf,options){var dejavu={};dejavu.Class=Class;dejavu.AbstractClass=AbstractClass;dejavu.Interface=Interface;dejavu.FinalClass=FinalClass;dejavu.instanceOf=instanceOf;dejavu.options=options;dejavu.mode="strict";window.dejavu=dejavu});require("dejavu",null,null,true)}());