options {
  // MULTI = true;
  STATIC = false;
  //  DEBUG_PARSER = true;
  //  DEBUG_LOOKAHEAD = true;
  //  DEBUG_TOKEN_MANAGER = true;
  // JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(QueryParser)

package org.vortikal.repositoryimpl.query.parser;

import java.io.StringReader;
import java.util.List;
import java.util.Iterator;

import org.vortikal.repository.resourcetype.PropertyTypeDefinition;
import org.vortikal.repository.ResourceTypeTree;
import org.vortikal.repositoryimpl.query.query.*;

/**
* Partial implementation of a query parser based on javacc.
* <p>Try the parser out with:
* <p>java -cp target/classes org.vortikal.repositoryimpl.queryparser.QueryParser "((pre:post=c AND s:s=s) OR ff=2211)"
*/
public class QueryParser implements Parser {

    private ResourceTypeTree resourceTypeTree;

    public QueryParser(ResourceTypeTree resourceTypeTree) {
        this(new StringReader(""));
        this.resourceTypeTree = resourceTypeTree;
    }

    public Query parse(String query) {
        ReInit(new StringReader(query));
        try {
            return Query();
        } catch (TokenMgrError tme) {
            throw new RuntimeException(tme.getMessage());
        } catch (ParseException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    private Query getExistsQuery(String prefix, String name, boolean exists) {
        PropertyTypeDefinition def = 
            resourceTypeTree.getPropertyDefinitionByPrefix(prefix, name);
        if (def == null)
            throw new RuntimeException("Unknown property " + prefix + ":" + name);

        return new PropertyExistsQuery(def, exists);
    }

    private Query getPropTermQuery(String prefix, String name, String value, 
                                   TermOperator operator) {
        PropertyTypeDefinition def = 
            resourceTypeTree.getPropertyDefinitionByPrefix(prefix, name);
        if (def == null)
            throw new RuntimeException("Unknown property " + prefix + ":" + name);

        return new PropertyTermQuery(def, value, operator);
    }

    private Query getPropPrefixQuery(String prefix, String name, String value) {
        PropertyTypeDefinition def = 
            resourceTypeTree.getPropertyDefinitionByPrefix(prefix, name);
        if (def == null)
            throw new RuntimeException("Unknown property " + prefix + ":" + name);

        return new PropertyPrefixQuery(def, value);
    }

    private String unescape(String escaped) {
        char[] caSource = escaped.toCharArray();
        char[] caDest = new char[caSource.length];
        int j = 0;
        for (int i = 0; i < caSource.length; i++) {
            if ((caSource[i] != '\\') || (i > 0 && caSource[i-1] == '\\')) {
                caDest[j++]=caSource[i];
            }
        }
        return new String(caDest, 0, j);
    }
}

PARSER_END(QueryParser)

<DEFAULT, Value> SKIP : {" "}

TOKEN : {
    <URI: "uri">
        | <NAME: "name">
        | <TYPE: "type">
        | <DEPTH: "depth">

        | <EQ: "="> : Value
        | <NE: "!="> : Value
        | <GT: ">"> : Value
        | <GE: ">="> : Value
        | <LT: "<"> : Value
        | <LE: "<="> : Value
        | <IN: "IN"> : Value
        | <NI: "NOT IN"> : Value

        | <AND: "AND" | "&&">
        | <OR: "OR" | "||">

        | <ASTERISK: "*">

        | <LP: "(">
        | <RP: ")">

        | <NLP: ~["(", ":"] >
        | <NRP: ~[")", ":"] >
}

TOKEN : { < COLON: ":"> }

TOKEN : { < EXISTS: "exists"> }
TOKEN : { < NOTEXISTS: "not exists" | "!exists"> }

TOKEN : { < #ID: ~[" ", "\\", "\"", "=", "<", ">", "!", "(", ")", ":"] > }
TOKEN : { < NAMEVALUE: (<ID> | <ESCAPED_CHAR>)+ > }

<DEFAULT, Value> TOKEN : {
    <ESCAPED_CHAR: "\\" (" " | "\\" | "!" | "(" | ")" | ":" | "\"" | "|" | "&" | "=" | "<" | ">") >
}

<Value> TOKEN : {
    <#VALUE_CHAR: (<ESCAPED_CHAR> | ~["*", " ", ")"]) > 
        | <VALUE: (<VALUE_CHAR>)+ > : DEFAULT
         | <WILDVALUE:  (<VALUE_CHAR> ((<VALUE_CHAR>)* ([ "*", "?" ])+ (<VALUE_CHAR>)*)+ <VALUE_CHAR>)> : DEFAULT
}


// Main method:
Query Query() : 
{
    Query q;
}
{ 
    ( 
        LOOKAHEAD((Closed() | SimpleQuery()) <AND>) q=AndQuery() 
        | LOOKAHEAD((Closed() | SimpleQuery()) <OR>) q=OrQuery() 
        | q=SimpleQuery() 
    )
        { return q; }
}

// Used for lookahead only:
void Closed() : {}
{
    <LP> (<ESCAPED_CHAR> | <COLON> | <NLP>)* [Closed() (<ESCAPED_CHAR> | <COLON> | <NRP>)*] <RP>
}


Query AndQuery() : 
{
    AndQuery q = new AndQuery();
    Query tmp;
}
{ 
    (
        tmp=SimpleQuery()
            { q.add(tmp);}
        (<AND> tmp=SimpleQuery()
            { q.add(tmp);}
        )+
    )
        { return q; }
}

Query OrQuery() : 
{
    OrQuery q = new OrQuery();
    Query tmp;
}
{ 
    (
        tmp=SimpleQuery()
            { q.add(tmp);}
        (<OR> tmp=SimpleQuery()
            { q.add(tmp);}
        )+
    )
        { return q; }
}

Query SimpleQuery() : 
{
    Query q;
}
{
    (
        q=ClosedQuery() 
        | LOOKAHEAD(2) q=NameQuery() 
        | LOOKAHEAD(2) q=UriQuery() 
        | LOOKAHEAD(2) q=TypeQuery()
        | LOOKAHEAD(2) q=DepthQuery() 
        | q=PropertyQuery()
    )
        { return q; }
}

Query ClosedQuery() : 
{
    Query q;
}
{
    <LP> q=Query() <RP>
        { return q;}
}

Query DepthQuery() : 
{
    Token t;
}
{
    <DEPTH> <EQ> t=<VALUE>
        { 	
        	// Should be validating this in the parser (?)
        	int depth = -1;
        	try {
	        	depth = Integer.parseInt(t.image);
        	} catch (NumberFormatException e) {
	            throw new RuntimeException("depth value not a legal integer");
        	}   
        	if (depth < 0)
	            throw new RuntimeException("depth value cannot negative");
        	 	
        	return new UriDepthQuery(depth); 
        }
}

Query UriQuery() : 
{
    Query q;
}
{
    (LOOKAHEAD(4) q=UriPrefixQuery() | q=UriTermQuery())
        { return q; }
}

Query UriPrefixQuery() : 
{
    Token t;
}
{
    <URI> <EQ> t=<VALUE> <ASTERISK>
        { return new UriPrefixQuery(t.image); }
}

Query UriTermQuery() : 
{
    Token t, eq = null, ne = null;
    UriOperator o;
}
{
    <URI> (eq=<EQ> | ne=<NE>) t=<VALUE>
        {  
            if (eq != null) 
                o = UriOperator.EQ;
            else
                o = UriOperator.NE;

            return new UriTermQuery(t.image, o);
        }
}


Query TypeQuery() : 
{
    Query q;
    Token eq = null, ne = null, in = null, ni = null, v;
    TypeOperator o;
}
{
    (<TYPE> (eq=<EQ> | ne=<NE> | in=<IN> | ni=<NI>) v=<VALUE>)
        { 
            TypeOperator operator = null;
            if (eq != null)
                o = TypeOperator.EQ;
            else if (ne != null)
                o = TypeOperator.NE;
            else if (in != null)
                o = TypeOperator.IN;
            else
                o = TypeOperator.NI;

            return new TypeTermQuery(v.image, o);
        }
}

Query NameQuery() : 
{
    Query q;
}
{
    (LOOKAHEAD(4) q=NamePrefixQuery() /**| q=NameRangeQuery() | q=NameWildcardQuery() **/| q=NameTermQuery())
        { return q; }
}

Query NamePrefixQuery() : 
{
    Token t;
}
{
    <NAME> <EQ> t=<VALUE> <ASTERISK>
        { return new UriPrefixQuery(t.image); }
}

Query NameTermQuery() : 
{
    Token t, eq = null, ne = null, gt = null, lt = null, ge = null, le = null;
    TermOperator operator;
}
{
    <NAME> (eq=<EQ> | ne=<NE> | gt=<GT> | lt=<LT> | ge=<GE> | le=<LE>) t=<VALUE>
        {  
            if (eq != null) 
                operator = TermOperator.EQ;
            else if (ne != null)
                operator = TermOperator.NE;
            else if (gt != null)
                operator = TermOperator.GT;
            else if (lt != null)
                operator = TermOperator.LT;
            else if (ge != null)
                operator = TermOperator.GE;
            else
                operator = TermOperator.LE;

            return new NameTermQuery(t.image, operator);
        }
}

// Query NameRangeQuery() :
// {}{}

// Query NameWildcardQuery() :
// {
// }{
// }

Query PropertyQuery() : 
{
    Query q;
}
{
    (LOOKAHEAD(4) q=PropertyExistsQuery() 
     | LOOKAHEAD(6) q=PropertyPrefixQuery()
     | q=PropertyTermQuery())
        { return q;}
}    

// Property exists:
Query PropertyExistsQuery() : {
    Token p=null, name, ex=null;
}
{
    ([LOOKAHEAD(2) p=<NAMEVALUE> <COLON>] name=<NAMEVALUE> (ex=<EXISTS> | <NOTEXISTS>))
        {
            String prefix = null;
            if (p != null) prefix = p.image;
            boolean exists = ex != null; 
            return getExistsQuery(prefix, name.image, exists);
        }

}

Query PropertyPrefixQuery() : 
{
    Token p=null, n, v;
}
{
    [LOOKAHEAD(2) p=<NAMEVALUE> <COLON>] n=<NAMEVALUE> 
        <EQ>
        //        ("\"" v=<VALUE> "\"" | v=<VALUE>)    
        v=<VALUE> <ASTERISK>
        { 
            String prefix = null;
            if (p != null) prefix = p.image;
            String name = n.image;
            
            String value = unescape(v.image);

            return getPropPrefixQuery(prefix, name, value); 
        }
}


// Property value query:
Query PropertyTermQuery() : {
    Token p=null, n, v;
    Token ne=null, ge=null, le=null, eq=null, gt=null, lt=null;
}
{
    [LOOKAHEAD(2) p=<NAMEVALUE> <COLON>] n=<NAMEVALUE> 
        (ne=<NE> | ge =<GE> | le=<LE> | eq=<EQ> | gt=<GT> | lt=<LT>)
        //        ("\"" v=<VALUE> "\"" | v=<VALUE>)    
        v=<VALUE>
        {
            String prefix = null;
            if (p != null) prefix = p.image;
            String name = n.image;
            
            String value = unescape(v.image);

            TermOperator operator = null;
            if (ne != null)
                operator = TermOperator.NE;
            else if (ge != null)
                operator = TermOperator.GE;
            else if (le != null)
                operator = TermOperator.LE;
            else if (eq != null)
                operator = TermOperator.EQ;
            else if (gt != null)
                operator = TermOperator.GT;
            else
                operator = TermOperator.LT;


            return getPropTermQuery(prefix, name, value, operator);
        }

}

