options {
  // MULTI = true;
  STATIC = false;
  //  DEBUG_PARSER = true;
  //  DEBUG_LOOKAHEAD = true;
  //  DEBUG_TOKEN_MANAGER = true;
  // JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(QueryParser)

package org.vortikal.repositoryimpl.query.parser;

import java.io.StringReader;
import java.util.List;
import java.util.Iterator;

import org.vortikal.repository.resourcetype.PropertyTypeDefinition;
import org.vortikal.repositoryimpl.PropertyManagerImpl;
import org.vortikal.repositoryimpl.query.query.*;

/**
* Partial implementation of a query parser based on javacc.
* <p>Try the parser out with:
* <p>java -cp target/classes org.vortikal.repositoryimpl.queryparser.QueryParser "((pre:post=c AND s:s=s) OR ff=2211)"
*/
public class QueryParser implements Parser {

    private PropertyManagerImpl propertyManager;

    public QueryParser(PropertyManagerImpl propertyManager) {
        this(new StringReader(""));
        this.propertyManager = propertyManager;
    }

    public Query parse(String query) {
        ReInit(new StringReader(query));
        try {
            return Query();
        } catch (TokenMgrError tme) {
            throw new RuntimeException(tme.getMessage());
        } catch (ParseException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    private Query getExistsQuery(String prefix, String name, boolean exists) {
        PropertyTypeDefinition def = 
            propertyManager.getPropertyDefinitionByPrefix(prefix, name);
        if (def == null)
            throw new RuntimeException("Unknown property " + prefix + ":" + name);

        return new PropertyExistsQuery(def, exists);
    }

}

PARSER_END(QueryParser)

<DEFAULT, Value> SKIP : {" "}

TOKEN : {
    <URI: "uri">
        | <NAME: "name">
        | <TYPE: "type">

        | <EQ: "="> : Value
        | <NE: "!="> : Value
        | <GT: ">"> : Value
        | <GE: ">="> : Value
        | <LT: "<"> : Value
        | <LE: "<="> : Value
        | <IN: "IN"> : Value
        | <NI: "NOT IN"> : Value

        | <AND: "AND" | "&&">
        | <OR: "OR" | "||">

        | <ASTERISK: "*">

        | <LP: "(">
        | <RP: ")">

        | <NLP: ~["(", ":"] >
        | <NRP: ~[")", ":"] >
}

TOKEN : { < COLON: ":"> }

TOKEN : { < EXISTS: "exists"> }
TOKEN : { < NOTEXISTS: "not exists" | "!exists"> }

TOKEN : { < #ID: ~[" ", "\\", "\"", "=", "<", ">", "!", "(", ")", ":"] > }
TOKEN : { < STRING: (<ID> | <ESCAPED_CHAR>)+ > }

<DEFAULT, Value> TOKEN : {
    <ESCAPED_CHAR: "\\" (" " | "\\" | "!" | "(" | ")" | ":" | "\"" | "|" | "&" | "=" | "<" | ">") >
}

<Value> TOKEN : {
    <#VALUE_CHAR: (<ESCAPED_CHAR> | ~["*", " ", ")"]) > 
        | <VALUE: (<VALUE_CHAR>)+ > : DEFAULT
         | <WILDVALUE:  (<VALUE_CHAR> ((<VALUE_CHAR>)* ([ "*", "?" ])+ (<VALUE_CHAR>)*)+ <VALUE_CHAR>)> : DEFAULT
}


// Main method:
Query Query() : 
{
    Query q;
}
{ 
    ( 
        LOOKAHEAD((Closed() | SimpleQuery()) <AND>) q=AndQuery() 
        | LOOKAHEAD((Closed() | SimpleQuery()) <OR>) q=OrQuery() 
        | q=SimpleQuery() 
    )
        { return q; }
}

// Used for lookahead only:
void Closed() : {}
{
    <LP> (<ESCAPED_CHAR> | <COLON> | <NLP>)* [Closed() (<ESCAPED_CHAR> | <COLON> | <NRP>)*] <RP>
}


Query AndQuery() : 
{
    AndQuery q = new AndQuery();
    Query tmp;
}
{ 
    (
        tmp=SimpleQuery()
            { q.add(tmp);}
        (<AND> tmp=SimpleQuery()
            { q.add(tmp);}
        )+
    )
        { return q; }
}

Query OrQuery() : 
{
    OrQuery q = new OrQuery();
    Query tmp;
}
{ 
    (
        tmp=SimpleQuery()
            { q.add(tmp);}
        (<OR> tmp=SimpleQuery()
            { q.add(tmp);}
        )+
    )
        { return q; }
}

Query SimpleQuery() : 
{
    Query q;
}
{
    (
        q=ClosedQuery() 
        | LOOKAHEAD(2) q=NameQuery() 
        | LOOKAHEAD(2) q=UriQuery() 
        | LOOKAHEAD(2) q=TypeQuery() 
        | q=PropertyQuery()
    )
        { return q; }
}

Query ClosedQuery() : 
{
    Query q;
}
{
    <LP> q=Query() <RP>
        { return q;}
}

Query UriQuery() : 
{
    Query q;
}
{
    (LOOKAHEAD(4) q=UriPrefixQuery() | q=UriTermQuery())
        { return q; }
}

Query UriPrefixQuery() : 
{
    Token t;
}
{
    <URI> <EQ> t=<VALUE> <ASTERISK>
        { return new UriPrefixQuery(t.image); }
}

Query UriTermQuery() : 
{
    Token t, eq = null, ne = null;
    UriOperator o;
}
{
    <URI> (eq=<EQ> | ne=<NE>) t=<VALUE>
        {  
            if (eq != null) 
                o = UriOperator.EQ;
            else
                o = UriOperator.NE;

            return new UriTermQuery(t.image, o);
        }
}


Query TypeQuery() : 
{
    Query q;
    Token eq = null, ne = null, in = null, ni = null, v;
    TypeOperator o;
}
{
    (<TYPE> (eq=<EQ> | ne=<NE> | in=<IN> | ni=<NI>) v=<VALUE>)
        { 
            TypeOperator operator = null;
            if (eq != null)
                o = TypeOperator.EQ;
            else if (ne != null)
                o = TypeOperator.NE;
            else if (in != null)
                o = TypeOperator.IN;
            else
                o = TypeOperator.NI;

            return new TypeTermQuery(v.image, o);
        }
}

Query NameQuery() : 
{
    Query q;
}
{
    (LOOKAHEAD(4) q=NamePrefixQuery() /**| q=NameRangeQuery() | q=NameWildcardQuery() **/| q=NameTermQuery())
        { return q; }
}

Query NamePrefixQuery() : 
{
    Token t;
}
{
    <NAME> <EQ> t=<VALUE> <ASTERISK>
        { return new UriPrefixQuery(t.image); }
}

Query NameTermQuery() : 
{
    Token t, eq = null, ne = null, gt = null, lt = null, ge = null, le = null;
    TermOperator o;
}
{
    <NAME> (eq=<EQ> | ne=<NE> | gt=<GT> | lt=<LT> | ge=<GE> | le=<LE>) t=<VALUE>
        {  
            if (eq != null) 
                o = TermOperator.EQ;
            else if (ne != null)
                o = TermOperator.NE;
            else if (gt != null)
                o = TermOperator.GT;
            else if (lt != null)
                o = TermOperator.LT;
            else if (ge != null)
                o = TermOperator.GE;
            else
                o = TermOperator.LE;

            return new NameTermQuery(t.image, o);
        }
}

// Query NameRangeQuery() :
// {}{}

// Query NameWildcardQuery() :
// {
// }{
// }

Query PropertyQuery() : 
{
    Query q;
}
{
    (LOOKAHEAD(4) q=PropertyExistsQuery() /*| q=PropertyTermQuery()*/)
        { return q;}
}    





// Property exists:
Query PropertyExistsQuery() : {
    Token p=null, name, ex=null;
}
{
    ([LOOKAHEAD(2) p=<STRING> <COLON>] name=<STRING> (ex=<EXISTS> | <NOTEXISTS>))
        {
            String prefix = null;
            if (p != null) prefix = p.image;
            boolean exists = ex != null; 
            return getExistsQuery(prefix, name.image, exists);
        }

}

// Property value query:
// void PropertyValueQuery() : {}
// {
//     [LOOKAHEAD(2) Prefix() <COLON>] Name() ComparatorValue()
// }

// void ComparatorValue() #void : {}
// {
//     Comparator() Value()
// }

// void Prefix() : 
// {
//     Token t;
// }
// {
//   t=<STRING>
//   {
//     jjtThis.setValue(t.image);
//   }
// }

// void Name() : 
// {
//     Token t;
// }
// {
//   t=<STRING>
//   {
//     jjtThis.setValue(t.image);
//   }
// }

// void Value() : 
// {
//   Token t;
// }
// {
//     ("\"" t=<STRING> "\"" | t=<STRING>)
//   {
      
//       jjtThis.setValue(unescape(t.image));
//   }
// }

// }
