options {
  MULTI = true;
  STATIC = false;
  //  DEBUG_PARSER = true;
  //  DEBUG_LOOKAHEAD = true;
  //  DEBUG_TOKEN_MANAGER = true;
  //  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(QueryParser)

package org.vortikal.repositoryimpl.queryparser;

import java.io.StringReader;


/**
* Partial implementation of a query parser based on javacc.
* <p>Try the parser out with:
* <p>java -cp target/classes org.vortikal.repositoryimpl.queryparser.QueryParser "((pre:post=c AND s:s=s) OR ff=2211)"
*/
public class QueryParser {

  public static void main(String args[]) throws ParseException {
    if (args.length == 0) {
      System.out.println("Usage: java org.vortikal.repositoryimpl.queryparser.QueryParser <input>");
      System.exit(0);
    }
    QueryParser parser = new QueryParser(new StringReader(args[0]));
    SimpleNode q = parser.parse();
    System.out.println(args[0]);
    q.dump("");

  }

    private String unescape(String escaped) {
        char[] caSource = escaped.toCharArray();
        char[] caDest = new char[caSource.length];
        int j = 0;
        for (int i = 0; i < caSource.length; i++) {
            if ((caSource[i] != '\\') || (i > 0 && caSource[i-1] == '\\')) {
                caDest[j++]=caSource[i];
            }
        }
        return new String(caDest, 0, j);
    }
}

PARSER_END(QueryParser)

SKIP : {" "}

TOKEN : { < LP: "("> }
TOKEN : { < RP: ")"> }

TOKEN : { <#ESCAPED_CHAR: "\\" [" ", "\\", "!", "(", ")", ":", "\"", "|", "&", "=", "<", ">" ] > }
TOKEN : { < EQ: "="> }
TOKEN : { < GT: ">"> }
TOKEN : { < LT: "<"> }
TOKEN : { < NEQ: "!="> }
TOKEN : { < GTE: ">="> }
TOKEN : { < LTE: "<="> }

TOKEN : { < AND: "AND" | "&&"> }
TOKEN : { < OR: "OR" | "||"> }
TOKEN : { < COLON: ":"> }

TOKEN : { < #ID: (~[" ", "\\", "\"", "=", "<", ">", "!", "(", ")", ":"])+ > }
TOKEN : { < STRING: (<ID> | <ESCAPED_CHAR>)+ > }

// Don't know how to introduce this yet...
TOKEN : { < #QUOTED: (~["\""])+ > }

// Main method:
SimpleNode parse() : {}
{ 
    Query() 
        { return jjtThis; }
}

void Query() #void : {}
{
    (
     LOOKAHEAD(1000, (Parantheses() | PropertyQuery()) <AND>) AndQuery() 
     | LOOKAHEAD(1000, (ClosedQuery() | PropertyQuery()) <OR>) OrQuery() 
    | ClosedQuery()
    | PropertyQuery()
    )    
}

void Parantheses() :
{}
{
    <LP> (Comparator() | <AND> | <OR> | <COLON> | <STRING> | Parantheses())* <RP>
}

void ClosedQuery() #void : {}
{
    <LP> Query() <RP>
}

void AndQuery() : {}
{
    (ClosedQuery() | PropertyQuery())
    (<AND> (ClosedQuery() | PropertyQuery()) )+
}

void OrQuery() : {}
{
    (ClosedQuery() | PropertyQuery())
    (<OR> (ClosedQuery() | PropertyQuery()) )+
}

void PropertyQuery() : {}
{ 
    [LOOKAHEAD(2) Prefix() <COLON>] Name() Comparator() Value()
}

void Comparator() : 
{ 
    Token t;
}
{
    ( t=<NEQ> | t=<GTE> | t=<LTE> | t=<EQ> | t=<GT> | t=<LT> )
    { 
        jjtThis.setValue(t.image); 
    }
}

void Prefix() : 
{
    Token t;
}
{
  t=<STRING>
  {
    jjtThis.setValue(t.image);
  }
}

void Name() : 
{
    Token t;
}
{
  t=<STRING>
  {
    jjtThis.setValue(t.image);
  }
}

void Value() : 
{
  Token t;
}
{
    ("\"" t=<STRING> "\"" | t=<STRING>)
  {
      
      jjtThis.setValue(unescape(t.image));
  }
}
